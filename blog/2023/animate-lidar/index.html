<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Animating LiDAR point clouds in R | Code, Maps, and More </title> <meta name="author" content="Keenan Ganz"> <meta name="description" content="Animations with LidR and rgl"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8C%8E&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://s-kganz.github.io/blog/2023/animate-lidar/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="//"> Code, Maps, and More </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Animating LiDAR point clouds in R</h1> <p class="post-meta"> Created in September 21, 2023 </p> <p class="post-tags"> <a href="//blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Recently I gave a brief presentation at <a href="https://cugos.org/" rel="external nofollow noopener" target="_blank">CUGOS</a> about some LiDAR animations I’ve been working on. There was a fair amount of ooh and aah (if I do say so myself), so this post is a brief how-to of how to animate LiDAR data in R. As an example, here is an animation of downwelling radiation in a forest canopy during a typical day in August.</p> <iframe width="560" height="315" src="https://www.youtube.com/embed/zl5cQ7XOIA4?si=Rcz9jzTHTYIZ6Ewn" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""> </iframe> <p>I started working on this because I was taking a LiDAR cloud, which is already 3-dimensional, and adding a temporal dimension with data from the flux tower in Wind River Experimental Forest. Visualizing 4-dimensions statically is really hard, and animations are really pretty anyway.</p> <p>I’m going to assume that you have basic knowledge of working with LiDAR data in R. If not, I highly recommend the <a href="https://r-lidar.github.io/lidRbook/" rel="external nofollow noopener" target="_blank">lidR book</a> and <a href="https://www.neonscience.org/resources/learning-hub/tutorials/create-chm-rasters-r" rel="external nofollow noopener" target="_blank">this tutorial</a> from NSF NEON. We aren’t going to use any of the processing features in <code class="language-plaintext highlighter-rouge">lidR</code>, so if you know how to plot a cloud with it you are good to go. Also, this approach only works well with small clips of airborne LiDAR. If you have a huge dataset, <code class="language-plaintext highlighter-rouge">rgl</code> will really struggle.</p> <h2 id="setup">Setup</h2> <p>There are three key packages: <code class="language-plaintext highlighter-rouge">lidR</code>, <code class="language-plaintext highlighter-rouge">rgl</code>, and <code class="language-plaintext highlighter-rouge">rglplus</code>. <code class="language-plaintext highlighter-rouge">lidR</code> is the most popular R package for reading and manipulating LiDAR data, while <code class="language-plaintext highlighter-rouge">rgl</code> and <code class="language-plaintext highlighter-rouge">rglplus</code> provide 3D visualization utilities.</p> <p>We generate animations with the function <code class="language-plaintext highlighter-rouge">rglplus::rgl.makemovie</code>. This function calls ffmpeg under the hood to convert a series of image files into an MP4 video. You will need to have ffmpeg installed <em>and accessible from the RStudio terminal</em> for this to work. If you don’t have that for some reason, <code class="language-plaintext highlighter-rouge">rgl.makemovie</code> will generate a directory of image files for each frame of the animation. You can then encode all of those into a video with the tool of your choice.</p> <p>With all that said, let’s build the structure of our first animation.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">lidR</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rgl</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rglplus</span><span class="p">)</span><span class="w">

</span><span class="c1"># Toy data included with lidR</span><span class="w">
</span><span class="n">LASfile</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">system.file</span><span class="p">(</span><span class="s2">"extdata"</span><span class="p">,</span><span class="w"> </span><span class="s2">"MixedConifer.laz"</span><span class="p">,</span><span class="w"> </span><span class="n">package</span><span class="o">=</span><span class="s2">"lidR"</span><span class="p">)</span><span class="w">
</span><span class="n">las</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readLAS</span><span class="p">(</span><span class="n">LASfile</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>The way we generate animations is with <code class="language-plaintext highlighter-rouge">rglplus::rgl.makemovie</code>. This function works by effectively taking a screenshot of the active rgl scene, and then concatenating all of those together in an MP4 video using ffmpeg. Fortunately for us, <code class="language-plaintext highlighter-rouge">lidR::plot</code> uses rgl as its backend, so we can easily pair those two together. The most important argument to <code class="language-plaintext highlighter-rouge">rgl.makemovie</code> is <code class="language-plaintext highlighter-rouge">frame</code>. <code class="language-plaintext highlighter-rouge">frame</code> is a function of one argument that updates the current rgl context before the next frame of the animation is captured.</p> <p>To start with, we are just going to plot the point cloud and add some text indicating the current frame time. Call the function and you should see the cloud with some text, like so.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_frame_func</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">close3d</span><span class="p">()</span><span class="w">            </span><span class="c1"># Close the current scene if one exists</span><span class="w">
  </span><span class="n">plot</span><span class="p">(</span><span class="n">las</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w"> </span><span class="c1"># Plot the point cloud</span><span class="w">
  </span><span class="n">display_t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.character</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">))</span><span class="w">
  </span><span class="n">text3d</span><span class="p">(</span><span class="m">40</span><span class="p">,</span><span class="w"> </span><span class="m">40</span><span class="p">,</span><span class="w"> </span><span class="m">60</span><span class="p">,</span><span class="w"> </span><span class="n">display_t</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="o">=</span><span class="s2">"white"</span><span class="p">)</span><span class="w"> </span><span class="c1"># add text at the point (40, 40, 60)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_frame_func</span><span class="p">(</span><span class="m">0.5</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p><img src="/assets/img/example-frame-1.png" alt=""></p> <p>Now let’s call this function with <code class="language-plaintext highlighter-rouge">rgl.makemovie</code>.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">anim_time</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="n">fps</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">30</span><span class="w">
</span><span class="n">out_dir</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tempdir</span><span class="p">()</span><span class="w">

</span><span class="n">rgl.makemovie</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">my_frame_func</span><span class="p">,</span><span class="w"> </span><span class="n">tmin</span><span class="o">=</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">tmax</span><span class="o">=</span><span class="n">anim_time</span><span class="p">,</span><span class="w"> </span><span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">nframes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anim_time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">output.path</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span><span class="w">
              </span><span class="n">output.filename</span><span class="o">=</span><span class="s2">"my_movie1.mp4"</span><span class="p">,</span><span class="w">
              </span><span class="n">quiet</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>You should see a bunch of output, and a series of rgl windows opening and closing quickly. In the above, I’m writing the output to a temporary directory. If you open that directory, you should see a file called <code class="language-plaintext highlighter-rouge">my_movie.mp4</code>. Open the video, and you should see a simple render of your point cloud and some white text that goes from 0 to 1. Now let’s build from this.</p> <h2 id="3d-visualization-parameters">3D visualization parameters</h2> <p><code class="language-plaintext highlighter-rouge">rgl</code> gives us several ways to play with the camera and window size that are exposed through the function <code class="language-plaintext highlighter-rouge">par3d</code>. This function returns a named list with all the grahpics settings of the current scene. Plot up the point cloud and then call this function.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">las</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">par3d</span><span class="p">()</span><span class="w">
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $antialias
## [1] 8
## 
## $FOV
## [1] 30
## 
## $ignoreExtent
## [1] FALSE
## 
## $listeners
## [1] 472
## 
## $mouseMode
##        none        left       right      middle       wheel 
##      "none" "trackball"      "user"       "fov"      "pull" 
## 
## $observer
## [1]   0.000   0.000 253.424
## 
## $modelMatrix
##      [,1]       [,2]      [,3]       [,4]
## [1,]    1  0.0000000 0.0000000  -44.99500
## [2,]    0  0.3420202 0.9396926  -30.44178
## [3,]    0 -0.9396926 0.3420202 -216.66910
## [4,]    0  0.0000000 0.0000000    1.00000
## 
## $projMatrix
##          [,1]     [,2]      [,3]      [,4]
## [1,] 3.732051 0.000000  0.000000    0.0000
## [2,] 0.000000 3.732051  0.000000    0.0000
## [3,] 0.000000 0.000000 -3.863703 -913.5641
## [4,] 0.000000 0.000000 -1.000000    0.0000
## 
## $skipRedraw
## [1] FALSE
## 
## $userMatrix
##      [,1]       [,2]      [,3] [,4]
## [1,]    1  0.0000000 0.0000000    0
## [2,]    0  0.3420201 0.9396926    0
## [3,]    0 -0.9396926 0.3420201    0
## [4,]    0  0.0000000 0.0000000    1
## 
## $userProjection
##      [,1] [,2] [,3] [,4]
## [1,]    1    0    0    0
## [2,]    0    1    0    0
## [3,]    0    0    1    0
## [4,]    0    0    0    1
## 
## $scale
## [1] 1 1 1
## 
## $viewport
##      x      y  width height 
##      0      0    256    256 
## 
## $zoom
## [1] 1
## 
## $bbox
## [1]  0.00 89.99  0.00 89.90  0.00 32.07
## 
## $windowRect
## [1] 138 161 394 417
## 
## $family
## [1] "sans"
## 
## $font
## [1] 1
## 
## $cex
## [1] 1
## 
## $useFreeType
## [1] FALSE
## 
## $fontname
## [1] "TT Arial"
## 
## $maxClipPlanes
## [1] 8
## 
## $glVersion
## [1] 4.6
## 
## $activeSubscene
## [1] 0
</code></pre></div></div> <p>There’s a lot going on here, most of which we don’t really care about. Reading the documentation is a good place to start understanding what all this means, but it is also helpful to play with the cloud and then call <code class="language-plaintext highlighter-rouge">par3d</code> again. Resize the window, then <code class="language-plaintext highlighter-rouge">viewport</code> and <code class="language-plaintext highlighter-rouge">windowRect</code> change. Click and drag the cloud, then <code class="language-plaintext highlighter-rouge">userMatrix</code> and <code class="language-plaintext highlighter-rouge">modelMatrix</code> change. There are 4 parameters we care about: <code class="language-plaintext highlighter-rouge">userMatrix</code>, <code class="language-plaintext highlighter-rouge">userProjection</code>, <code class="language-plaintext highlighter-rouge">windowRect</code>, and <code class="language-plaintext highlighter-rouge">scale</code>.</p> <p>This gives us a way to set up a window size and view angle and then apply it to an animation. Try changing the scene around, then save the parameters in a list. We can then supply this to <code class="language-plaintext highlighter-rouge">par3d</code> in our frame function. One important detail is that the <strong>window size must be divisible by 2 for the conversion to MP4 to work</strong>.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># After moving the cloud around...</span><span class="w">
</span><span class="n">mypar</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">par3d</span><span class="p">()[</span><span class="nf">c</span><span class="p">(</span><span class="s2">"userMatrix"</span><span class="p">,</span><span class="w"> </span><span class="s2">"userProjection"</span><span class="p">,</span><span class="w">
                   </span><span class="s2">"windowRect"</span><span class="p">,</span><span class="w"> </span><span class="s2">"scale"</span><span class="p">)]</span><span class="w">

</span><span class="c1"># Make sure the window size is divisible by 2</span><span class="w">
</span><span class="n">mypar</span><span class="o">$</span><span class="n">windowRect</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span><span class="n">mypar</span><span class="o">$</span><span class="n">windowRect</span><span class="o">/</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">2</span><span class="w">

</span><span class="n">my_frame_func2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1"># Same as before...</span><span class="w">
  </span><span class="n">my_frame_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w">
  </span><span class="c1"># Except now we set the new view parameters</span><span class="w">
  </span><span class="n">par3d</span><span class="p">(</span><span class="n">mypar</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">rgl.makemovie</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">my_frame_func2</span><span class="p">,</span><span class="w"> </span><span class="n">tmin</span><span class="o">=</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">tmax</span><span class="o">=</span><span class="n">anim_time</span><span class="p">,</span><span class="w"> </span><span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">nframes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anim_time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">output.path</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span><span class="w">
              </span><span class="n">output.filename</span><span class="o">=</span><span class="s2">"my_movie2.mp4"</span><span class="p">,</span><span class="w">
              </span><span class="n">quiet</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>Now you should get a new animation with the camera and window size adjusted like before. Next, we will learn how to manipulate the point cloud within the scene.</p> <h2 id="rotating-the-cloud">Rotating the cloud</h2> <p>If we want the point cloud to move within our scene, we have two options: move the camera, or move the point cloud. In my experience I find moving the point cloud easier. But, you could also accomplish this by modifying <code class="language-plaintext highlighter-rouge">userMatrix</code> and <code class="language-plaintext highlighter-rouge">observer</code> with <code class="language-plaintext highlighter-rouge">par3d</code>.</p> <p>At its core, LiDAR data is just a matrix of points in 3D space. The <code class="language-plaintext highlighter-rouge">lidR</code> package lets us access that data through the <code class="language-plaintext highlighter-rouge">$data</code> slot. To rotate points in 3D space, we turn to <a href="https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions" rel="external nofollow noopener" target="_blank">rotation matrices</a>. This can be a little tricky, so let’s start by just rotating our existing point cloud.</p> <p>Rotation matrices will spin points around the origin (0, 0, 0). But, if we check the data in our point cloud, we find that the points are far from the origin.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">las</span><span class="w">
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class        : LAS (v1.2 format 1)
## memory       : 2.2 Mb 
## extent       : 481260, 481350, 3812921, 3813011 (xmin, xmax, ymin, ymax)
## coord. ref.  : NAD83 / UTM zone 12N 
## area         : 8072 m²
## points       : 37.7 thousand points
## density      : 4.67 points/m²
## density      : 4.67 pulses/m²
</code></pre></div></div> <p>You can still do the rotation without accounting for the offset, but the result will be way off in space. So, really we have three steps.</p> <ol> <li>Center the original data at the origin</li> <li>Apply the rotation</li> <li>Re-offset the rotated data at the original position (if needed)</li> </ol> <p>Fortunately this is pretty easy since we can get the appropriate offset with the mean of each coordinate.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">offset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="w">
  </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">X</span><span class="p">),</span><span class="w">
  </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">Y</span><span class="p">),</span><span class="w">
  </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">Z</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">

</span><span class="c1"># Only grab the XYZ coordinates</span><span class="w">
</span><span class="n">las_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">]</span><span class="w"> 
</span><span class="c1"># Sweep subtracts a constant from each column</span><span class="w">
</span><span class="c1"># See https://stackoverflow.com/questions/24520720/subtract-a-constant-vector-from-each-row-in-a-matrix-in-r</span><span class="w">
</span><span class="n">las_data_center</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sweep</span><span class="p">(</span><span class="n">las_data</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="o">=</span><span class="s2">"-"</span><span class="p">)</span><span class="w"> 

</span><span class="c1"># Check that it worked - ranges are centered on zero</span><span class="w">
</span><span class="n">apply</span><span class="p">(</span><span class="n">las_data_center</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">range</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##              X         Y         Z
## [1,] -45.19922 -45.23283 -12.01463
## [2,]  44.79078  44.66717  20.05537
</code></pre></div></div> <p>With our data centered, we can now rotate it without messing up the coordinate space. First we make the rotation matrix. For more complex movements, you can also use <code class="language-plaintext highlighter-rouge">rgl::rotationMatrix</code>.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ~45 degrees in radians</span><span class="w">
</span><span class="n">theta</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0.785</span><span class="w">
</span><span class="c1"># Manually create the matrix</span><span class="w">
</span><span class="n">rot_mtx_y45</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">matrix</span><span class="p">(</span><span class="w">
  </span><span class="nf">c</span><span class="p">(</span><span class="w"> 
     </span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">  </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">
              </span><span class="m">0</span><span class="p">,</span><span class="w">  </span><span class="m">1</span><span class="p">,</span><span class="w">          </span><span class="m">0</span><span class="p">,</span><span class="w">
    </span><span class="o">-</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">  </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w">
  </span><span class="p">),</span><span class="w">
  </span><span class="n">nrow</span><span class="o">=</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="m">3</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>Then we apply the matrix to our centered data.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Make sure to use the matrix multiplication operator!</span><span class="w">
</span><span class="c1"># t() is the transpose function, it ensures the matrix dimensions</span><span class="w">
</span><span class="c1"># remain how we want them.</span><span class="w">
</span><span class="n">las_data_center_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">rot_mtx_y45</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">las_data_center</span><span class="p">))</span><span class="w"> 
</span></code></pre></div></div> <p>Next we reapply the offset so the rotated cloud is near the old one. You can ignore this step if you don’t care about having similar coordinates to the original, it won’t affect the animation result.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Do the reverse of the sweep call from before</span><span class="w">
</span><span class="n">las_data_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sweep</span><span class="p">(</span><span class="n">las_data_center_rotate</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="o">=</span><span class="s2">"+"</span><span class="p">)</span><span class="w">
</span><span class="c1"># Check that it worked again - ranges are similar to the original cloud.</span><span class="w">
</span><span class="n">apply</span><span class="p">(</span><span class="n">las_data_rotate</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">range</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##          [,1]    [,2]      [,3]
## [1,] 481265.5 3812921 -28.41818
## [2,] 481345.3 3813011  52.62642
</code></pre></div></div> <p>Finally, we rebuild the LAS object so we can plot it. Modifying the data slot directly like this can invalidate the internal LAS specification, preventing you from saving out the rotated data. But if you only care about animating then it’s whatever. If you know of a less hacky way, let me know :)</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">las_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las</span><span class="w">
</span><span class="n">las_rotate</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">]</span><span class="w">
</span><span class="n">las_rotate</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w">
</span><span class="n">las_rotate</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w">

</span><span class="n">plot</span><span class="p">(</span><span class="n">las_rotate</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p><img src="/assets/img/rot-example4-1.png" alt=""></p> <p>And there you go, a point cloud on a slant. You may be asking yourself why on Earth you would ever need this. One example is modeling how light moves through a canopy. Sunlight almost never hits a forest canopy at nadir, and accounting for solar angle can be important in early morning or high-latitude environments.</p> <h2 id="bring-it-all-together">Bring it all together</h2> <p>Now let’s animate a spinning cloud. First, let’s functionalize some code.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rot_matrix_y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1"># Make a rotation matrix about the y axis</span><span class="w">
  </span><span class="n">matrix</span><span class="p">(</span><span class="w">
    </span><span class="nf">c</span><span class="p">(</span><span class="w"> 
       </span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">  </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">
                </span><span class="m">0</span><span class="p">,</span><span class="w">  </span><span class="m">1</span><span class="p">,</span><span class="w">          </span><span class="m">0</span><span class="p">,</span><span class="w">
      </span><span class="o">-</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">  </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w">
    </span><span class="p">),</span><span class="w">
    </span><span class="n">nrow</span><span class="o">=</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="m">3</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">rotate_las</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">las</span><span class="p">,</span><span class="w"> </span><span class="n">rot_mtx</span><span class="p">,</span><span class="w"> </span><span class="n">do_offset</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">do_offset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="w">
      </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">X</span><span class="p">),</span><span class="w">
      </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">Y</span><span class="p">),</span><span class="w">
      </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">Z</span><span class="p">)</span><span class="w">
    </span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="n">las_data_center</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sweep</span><span class="p">(</span><span class="n">las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">],</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="o">=</span><span class="s2">"-"</span><span class="p">)</span><span class="w">
  </span><span class="n">las_data_center_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">rot_mtx</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">las_data_center</span><span class="p">))</span><span class="w">
  </span><span class="n">las_data_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sweep</span><span class="p">(</span><span class="n">las_data_center_rotate</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="o">=</span><span class="s2">"+"</span><span class="p">)</span><span class="w">
  
  </span><span class="n">new_las</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las</span><span class="w">
  </span><span class="n">new_las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">]</span><span class="w">
  </span><span class="n">new_las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w">
  </span><span class="n">new_las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w">
  
  </span><span class="n">new_las</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>Now we modify the frame function to rotate the cloud at an angle dependent on the animation time.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_frame_func3</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">close3d</span><span class="p">()</span><span class="w">
  </span><span class="c1"># Use the animation time as the rotation angle</span><span class="w">
  </span><span class="n">theta</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">t</span><span class="w"> 
  </span><span class="c1"># Rotate the cloud</span><span class="w">
  </span><span class="n">rot_mtx</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rot_matrix_y</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w">
  </span><span class="n">las_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rotate_las</span><span class="p">(</span><span class="n">las</span><span class="p">,</span><span class="w"> </span><span class="n">rot_mtx</span><span class="p">)</span><span class="w">
  </span><span class="c1"># Plot everything else as before</span><span class="w">
  </span><span class="n">plot</span><span class="p">(</span><span class="n">las_rotate</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
  </span><span class="n">display_t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.character</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">))</span><span class="w">
  </span><span class="n">text3d</span><span class="p">(</span><span class="m">40</span><span class="p">,</span><span class="w"> </span><span class="m">40</span><span class="p">,</span><span class="w"> </span><span class="m">60</span><span class="p">,</span><span class="w"> </span><span class="n">display_t</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="o">=</span><span class="s2">"white"</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>And we should now get a video of a spinning point cloud. I’m changing the frame time and fps so it doesn’t take as long to animate.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">anim_time</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">6.28</span><span class="w"> </span><span class="c1"># get a full rotation</span><span class="w">
</span><span class="n">fps</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">15</span><span class="w">
</span><span class="n">rgl.makemovie</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">my_frame_func3</span><span class="p">,</span><span class="w"> </span><span class="n">tmin</span><span class="o">=</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">tmax</span><span class="o">=</span><span class="n">anim_time</span><span class="p">,</span><span class="w"> </span><span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">nframes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anim_time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">output.path</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span><span class="w">
              </span><span class="n">output.filename</span><span class="o">=</span><span class="s2">"my_movie3.mp4"</span><span class="p">,</span><span class="w">
              </span><span class="n">quiet</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>And there you have it. This only scratches the surface of what is feasible with <code class="language-plaintext highlighter-rouge">lidR</code> and <code class="language-plaintext highlighter-rouge">rgl</code>. We could just as easily compute something about the point cloud in each frame and modify the color ramp to represent that (I did exactly that in the example embedded at the start of this post) Although this approach is fairly hacky, there are not many open-source tools that let you build animations with LiDAR. The next best option, especially for large datasets, would probably be the animation plugin in CloudCompare (example <a href="https://www.youtube.com/watch?v=aqfoYPzqUoE" rel="external nofollow noopener" target="_blank">here</a>). However, that approach is not programmatic, does not allow editing the point color, and requires you to set key frames manually.</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Keenan Ganz. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: November 21, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>