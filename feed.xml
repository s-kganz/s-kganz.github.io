<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://s-kganz.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://s-kganz.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-02T22:28:07+00:00</updated><id>https://s-kganz.github.io/feed.xml</id><title type="html">Code, Maps, and More</title><subtitle></subtitle><entry><title type="html">The most circular lakes in the US</title><link href="https://s-kganz.github.io/blog/2024/circles/" rel="alternate" type="text/html" title="The most circular lakes in the US"/><published>2024-11-21T12:00:00+00:00</published><updated>2024-11-21T12:00:00+00:00</updated><id>https://s-kganz.github.io/blog/2024/circles</id><content type="html" xml:base="https://s-kganz.github.io/blog/2024/circles/"><![CDATA[<p>At <a href="https://cugos.org/">CUGOS</a> this month we decided to do the 30-day map challenge collaboratively. Everyone picked a map to do and we all came together to show off what we came up with. My task was “only circular shapes”. After some thinking, I had an idea: find the most circular lake in each US state.</p> <p><a href="https://aslopubs.onlinelibrary.wiley.com/doi/full/10.1002/lno.12475">Lake geometry is pretty cool.</a> And wouldn’t you know, the <a href="https://lagoslakes.org/">LAGOS</a> team has curated a fantastic dataset of lake polygons for the conterminous United States. I wanted to give myself an additional challenge for this map: don’t use more than 1 GB of RAM. Let us begin!</p> <h2 id="calculating-circle-ness">Calculating circle-ness</h2> <p>There are a few methods out there for calculating polygon roundness, but for this map I want a direct measure of how circular a lake is. To do so, we construct a circle with the same area as a basin, center it on the lake centroid, then calculate the intersection of the lake and the circle. The ratio of the intersection area to lake area is our measure of circle-ness. Fortunately the <code class="language-plaintext highlighter-rouge">shapely</code> library makes this easy to do in Python.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">shapely</span>

<span class="k">def</span> <span class="nf">circle_of_same_area</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">shapely</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="n">MultiPolygon</span><span class="p">):</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">shape</span><span class="p">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">circle</span> <span class="o">=</span> <span class="n">shapely</span><span class="p">.</span><span class="nf">centroid</span><span class="p">(</span><span class="n">shape</span><span class="p">).</span><span class="nf">buffer</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circle</span>

<span class="k">def</span> <span class="nf">overlap_with_circle</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">shapely</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="n">MultiPolygon</span><span class="p">):</span>
    <span class="n">circle</span> <span class="o">=</span> <span class="nf">circle_of_same_area</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">circle</span><span class="p">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">shape</span><span class="p">).</span><span class="n">area</span> <span class="o">/</span> <span class="n">circle</span><span class="p">.</span><span class="n">area</span>
</code></pre></div></div> <p>For example, here is the result for Trout Pond in Aroostook county, Maine (LAGOS lake ID 55038).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/circles1-480.webp 480w,/assets/img/circles1-800.webp 800w,/assets/img/circles1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/circles1.png" class="img-fluid" width="50%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="reading-in-chunks">Reading in chunks</h2> <p>The full uncompressed LAGOS geopackage is a little over 18 GB on disk. So, we have to read the data in chunks to stay within our 1 GB limit. The function <code class="language-plaintext highlighter-rouge">gpd.read_file</code> has a parameter <code class="language-plaintext highlighter-rouge">rows</code> that lets us read a subset of a file. We select a small chunk size and iterate over the whole geopackage, only retaining the overlap index we need.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">osgeo</span> <span class="kn">import</span> <span class="n">ogr</span>
<span class="n">ogr</span><span class="p">.</span><span class="nc">UseExceptions</span><span class="p">()</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">geopandas</span> <span class="k">as</span> <span class="n">gpd</span>

<span class="n">dataset</span> <span class="o">=</span> <span class="sh">"</span><span class="s">gis_locus_v1.0.gpkg</span><span class="sh">"</span>

<span class="c1"># Get number of features without reading
# entire layer into memory
</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ogr</span><span class="p">.</span><span class="nc">Open</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span class="n">n_feats</span> <span class="o">=</span> <span class="n">ds</span><span class="p">.</span><span class="nc">GetLayer</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nc">GetFeatureCount</span><span class="p">()</span>
<span class="n">ds</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># close connection
</span>
<span class="c1"># Arbitrarily pick 20 chunks
</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="n">n_feats</span> <span class="o">//</span> <span class="mi">20</span>

<span class="c1"># Generator to create slice objects we pass to the
# rows parameter.
</span><span class="k">def</span> <span class="nf">enumerate_chunks</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
    <span class="n">upto</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">upto</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
        <span class="c1"># Add one because slice object are right-exclusive
</span>        <span class="nb">next</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">stop</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">upto</span><span class="o">+</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">upto</span><span class="p">,</span> <span class="nb">next</span>
        <span class="n">upto</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">def</span> <span class="nf">read_chunk_get_summary</span><span class="p">(</span><span class="n">chunk_tuple</span><span class="p">):</span>
    <span class="n">this_chunk</span> <span class="o">=</span> <span class="n">gpd</span><span class="p">.</span><span class="nf">read_file</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="nf">slice</span><span class="p">(</span><span class="o">*</span><span class="n">chunk_tuple</span><span class="p">),</span> <span class="n">layer</span><span class="o">=</span><span class="sh">"</span><span class="s">lake</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">this_chunk</span><span class="p">[</span><span class="sh">"</span><span class="s">overlap</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_chunk</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">overlap_with_circle</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">this_chunk</span><span class="p">[[</span><span class="sh">"</span><span class="s">lagoslakeid</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Shape_Area</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">overlap</span><span class="sh">"</span><span class="p">]]</span>

<span class="n">summary_df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">concat</span><span class="p">((</span><span class="nf">read_chunk_get_summary</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nf">enumerate_chunks</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">n_feats</span><span class="p">)))</span>    
</code></pre></div></div> <h2 id="winners-by-state">Winners by state</h2> <p>Now we attach a state attribute to our summary data frame, pick the one with the highest circle score, and extract only those rows from the original dataset.</p> <p>Since this isn’t meant to be a code post, you can find all the details on the github repo linked at the bottom of the page :P</p> <p>Now, let’s see some circles!</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/circles2-480.webp 480w,/assets/img/circles2-800.webp 800w,/assets/img/circles2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/circles2.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Yeah those are some circles all right. If you check out where all these lakes are on the below folium map, you’ll see that they are a) pretty small and b) usually made by people. The size part makes sense - lake shorelines become more complex as they grow larger. Since a circle has a very undeveloped shoreline, it follows that the most circular lakes will all be quite small.</p> <pre><code class="language-geojson">{
"type": "FeatureCollection",
"name": "circles",
"crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },
"features": [
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -88.052978582739385, 30.744749829632678 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -111.663277706234354, 35.238665123551179 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -92.785771954407579, 35.019589690947797 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -120.655089268233297, 35.245524043081055 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -105.90595761034885, 37.485828100061063 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -72.013872216950972, 41.843845432139254 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -75.521415560417395, 39.756793179254636 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -77.110913065066455, 38.939000655761816 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -81.612496673935752, 28.37723727603387 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -84.709442449156626, 31.725740802429907 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -115.304509688456065, 47.108110571919021 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -89.481225611173443, 37.722487375452324 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -86.984682116194534, 38.37355829374944 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -90.435500845389555, 41.772685315106763 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -101.860077413811268, 39.257770882062687 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -86.196682979739364, 37.954913061408263 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -90.497379178653688, 30.705945741329355 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -67.886453411928969, 44.771150683726461 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -75.905774601169398, 38.351596358749184 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -71.482099657116166, 42.432173600041914 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -84.412192967715711, 45.183397569090417 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -94.394959110077949, 46.939573661473581 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -88.694574135425142, 30.735727505618176 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -89.292873324205715, 36.640427869758668 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -109.301019092621587, 45.926509366933644 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -102.5760036365091, 42.031061043304916 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -114.744357903867268, 37.979576817629955 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -71.457117895505718, 43.074919451899696 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -74.346084463562207, 40.370738175093663 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -104.346681768150745, 33.233270528122652 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -78.840111762656448, 42.90473122359348 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -80.197902923375793, 35.399128704137361 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -98.971676078885054, 46.638768322706262 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -82.776494214141778, 41.214599568072231 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -96.439613443518127, 34.085738126677292 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -120.162529037423738, 43.429186103422488 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -79.009994703121436, 41.830627900157886 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -71.611648184126125, 41.488113838888452 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -82.307613035968487, 34.88292192955906 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -98.099192091449041, 45.43429891672276 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -84.759007180771249, 35.29843411546554 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -95.326706014552173, 28.940246275547963 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -113.776011815437002, 37.156371211650587 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -72.896477818937228, 44.72112013260935 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -79.026934347372034, 37.99903138626523 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -122.283142347024381, 47.856041468376489 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -80.779537671678668, 37.963985484904946 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -88.133127229017248, 45.510319466500029 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -107.257940206575483, 41.74360131567795 ] } }
]
}

</code></pre> <p>##</p> <h2 id="weighting-by-area">Weighting by area</h2> <p>Let’s see if we can make something a little more fun than a bunch of really tiny circles. To incentivize large, but still circular lakes, define a “circle score” as the overlap index we calculated above multiplied by the logarithm of lake area. Now who are the winners in each state?</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/circles_area_weight-480.webp 480w,/assets/img/circles_area_weight-800.webp 800w,/assets/img/circles_area_weight-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/circles_area_weight.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>And to complete the thought, where are these super-circles?</p> <pre><code class="language-geojson">{
"type": "FeatureCollection",
"name": "circle_scores",
"crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },
"features": [
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -88.004739745528113, 30.759234754445082 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -111.453746896531698, 34.94484660551543 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -93.99318311534509, 33.748982432916428 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -119.014775717982062, 38.007607356350647 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -104.073689968861046, 40.391892913057163 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -73.445813270207722, 41.955695332371327 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -75.256907060303917, 38.859841868426024 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -77.091666452105684, 38.911177647560912 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -80.796598628241767, 26.948641852366585 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -82.856043200324478, 34.392250217305282 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -111.40362587826526, 44.641506570950099 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -88.636952633928871, 41.254665862319314 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -87.757842529339655, 38.350708329049233 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -95.095651420219639, 43.477604371228054 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -95.802898694329414, 38.251502145897248 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -87.8108766841316, 37.680422764420825 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -90.125539190672612, 30.184095828662578 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -70.548586413322667, 43.856179971162149 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -75.305475583668354, 38.108931695321886 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -70.897358457275089, 41.800503603131773 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -84.721626930797058, 44.336977383221964 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -93.646218081124601, 46.242505670070642 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -90.701952190502922, 33.79178111391478 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -93.170947429723583, 39.614039278967823 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -111.681990121260171, 45.430958184414884 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -101.134951619656974, 41.106980982026741 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -118.717762519764591, 38.695450279099461 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -71.156641717828961, 43.596659875204061 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -74.825583500532474, 40.615890602604026 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -103.987698526209783, 32.320293090866066 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -78.997526696720129, 43.148329472964562 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -76.148752397780726, 35.508800286614893 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -98.831995351275424, 48.2473957561538 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -84.233298596431439, 40.737509610617899 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -97.59543109822431, 35.566480174814288 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -122.106387909063372, 42.942009844684016 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -79.009994703121436, 41.830627900157886 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -71.574828524283689, 41.439122668005126 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -80.053563651657569, 33.310488747393158 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -97.608670285630453, 44.493294614509836 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -89.694894097691133, 35.793584980549575 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -94.684297544096111, 29.802553237039607 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -112.601554645334971, 40.874586028652892 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -71.715722343569809, 44.955706919654929 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -76.469727848999668, 36.602823876265425 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -122.720457014987645, 45.679084357261111 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -81.763204491582044, 38.824872361183857 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -89.253647164448083, 42.964593040811209 ] } },
{ "type": "Feature", "properties": { }, "geometry": { "type": "Point", "coordinates": [ -108.601954773085694, 43.184804199884212 ] } }
]
}

</code></pre> <p>##</p> <h2 id="code">Code</h2> <p>Available <a href="https://github.com/s-kganz/lakes/blob/master/circles.ipynb">here</a>! This was a lot of fun. I wonder what happens if you look for the most square lakes… or the most spider-webby lakes.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[My contribution to #30DayMapChallenge]]></summary></entry><entry><title type="html">Should R packages document research results?</title><link href="https://s-kganz.github.io/blog/2024/r-packges/" rel="alternate" type="text/html" title="Should R packages document research results?"/><published>2024-04-12T12:00:00+00:00</published><updated>2024-04-12T12:00:00+00:00</updated><id>https://s-kganz.github.io/blog/2024/r-packges</id><content type="html" xml:base="https://s-kganz.github.io/blog/2024/r-packges/"><![CDATA[<p>Recently I’ve been hard at work modeling leaf temperature in evergreen forests. For various reasons, ecologists love to write R packages. This means that existing data access APIs and modeling code will most likely be available as an R package. This is a good thing - R is easy to read, quick to learn, and has a vibrant community of volunteer maintainers. I strongly believe that research, especially data-intensive work, should be reproducible. In this vein I wanted to take my project, refactor it as an R package, and then publish it on GitHub alongside the (forthcoming) manuscript.</p> <p>How hard could that refactoring be? The answer: quite hard. R makes some fundamental design choices that make it difficult to go from a researcher’s typical R script to a package. In this post I’ll discuss a few reasons why this is so, and suggest a better way to package research.</p> <h2 id="the-beginning">The beginning</h2> <p>Let’s say you are a researcher and you work in R. You organize your projects around a series of <code class="language-plaintext highlighter-rouge">.R</code> files that are structured something like this.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">somePackage</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">anotherPackage</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">yetAnotherPackage</span><span class="p">)</span><span class="w">

</span><span class="n">...</span><span class="w">
</span><span class="n">Do</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">kind</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">analysis</span><span class="w">
</span><span class="n">...</span><span class="w">

</span><span class="c1"># Save results</span><span class="w">
</span><span class="n">write_csv</span><span class="p">(</span><span class="n">spicy_result</span><span class="p">,</span><span class="w"> </span><span class="s2">"data_out/spicy_result.csv"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>This structure supports the interactive workflow people love about R. In this mode, you rarely <code class="language-plaintext highlighter-rouge">source</code> a whole file. Instead you go line-by-line, inspect outputs and plots, and iterate on an initial idea. In other words, you are free to put code that does different things all in one file. As you iterate on one file, your stack of <code class="language-plaintext highlighter-rouge">library()</code> calls at the top will get pretty large, even if you aren’t necessarily using all those libraries later on (when is the last time you saw an R tutorial use <code class="language-plaintext highlighter-rouge">::</code>?) Your script is less a self-contained program, and more a sketchpad that you return to as your analysis evolves.</p> <p>Suppose further that you use a directory structure to separate your data, scripts, and other outputs in a project. I like a structure like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.
├── scripts/
│   ├── util.R
│   └── models/
│       └── fit_my_model.R
├── data_in/
│   └── some_raw_data.csv
└── data_out/
    └── model_fit.csv
</code></pre></div></div> <p>This is very good practice to keep yourself organized.</p> <p>An important thing to note here is that <code class="language-plaintext highlighter-rouge">fit_my_model.R</code> might need access to functions in <code class="language-plaintext highlighter-rouge">util.R</code> to work. Assuming the working directory is the root of the project, you make these available with <code class="language-plaintext highlighter-rouge">source("scripts/util.R")</code> at the top of <code class="language-plaintext highlighter-rouge">fit_my_model.R</code>.</p> <h2 id="issue-1-everything-needs-to-be-a-function-now">Issue 1: Everything needs to be a function now</h2> <p>Step 1 in making a package from a jumble of standalone scripts is to start converting your code into functions. Although this is definitely work, there are two reasons why converting code to functions isn’t so bad. First, you can get off to a pretty good start by just surrounding a code block in <code class="language-plaintext highlighter-rouge">function() {...}</code> (RStudio even has a shortcut for this). Second, writing functions encourages modularity, keeps you from repeating yourself, and can get you to think harder about how you design your workflow. Still, depending on how late in your development process you decide to make a package, rewriting as functions can take a while.</p> <h2 id="issue-2-library-and-source-are-frowned-upon">Issue 2: <code class="language-plaintext highlighter-rouge">library()</code> and <code class="language-plaintext highlighter-rouge">source()</code> are frowned upon</h2> <p>When writing standalone scripts, <code class="language-plaintext highlighter-rouge">library()</code> and <code class="language-plaintext highlighter-rouge">source()</code> are effectively an informal dependency mechanism. You script depends on an external package if it attaches the package via <code class="language-plaintext highlighter-rouge">library()</code> at the top of the file. Likewise, your script depends on an external file via <code class="language-plaintext highlighter-rouge">source()</code>. In an R package, dependency rules are laid out formally in the DESCRIPTION file. Dependencies also have different “levels”. In order of importance, you dependencies can be listed under <code class="language-plaintext highlighter-rouge">Depends</code> (the dependency must be attached when your package loads), <code class="language-plaintext highlighter-rouge">Imports</code> (you call functions in the dependency, but the whole namespace doesn’t need to be loaded), or <code class="language-plaintext highlighter-rouge">Suggests</code> (the dependency is perhaps useful, but not required).</p> <p>Given this functionality, R packages should never use <code class="language-plaintext highlighter-rouge">library()</code>. Likewise, <code class="language-plaintext highlighter-rouge">source()</code> will never work in a package because you won’t know where your source code lives on the end user’s machine. I suppose you could get around that by hiding code in <code class="language-plaintext highlighter-rouge">inst/</code> and then using <code class="language-plaintext highlighter-rouge">system.file</code> to source it. Hacks like that are definitely not a good development pattern.</p> <p>So now we have to go through all our scripts and delete all the <code class="language-plaintext highlighter-rouge">library()</code> and <code class="language-plaintext highlighter-rouge">source()</code> calls. Not too much work. Then this raises another issue…</p> <h2 id="issuse-3-now-you-have-to-import-all-your-external-code">Issuse 3: Now you have to import all your external code</h2> <p>This is the first issue that took me a while to fix in my project. If you can’t make an external function available through <code class="language-plaintext highlighter-rouge">library()</code>, you have to list it in your package’s <code class="language-plaintext highlighter-rouge">DESCRIPTION</code> file and make it available accordingly. If you list an external package under <code class="language-plaintext highlighter-rouge">Depends</code>, you are done. External packages in <code class="language-plaintext highlighter-rouge">Depends</code> get attached when your package gets loaded, so it is as if you had called <code class="language-plaintext highlighter-rouge">library()</code> yourself. However, you can’t just spam every external package you used under <code class="language-plaintext highlighter-rouge">Depends</code>. There are <a href="https://recology.info/2018/10/limiting-dependencies/">general reasons not to</a>, but on a more practical level CRAN will reject packages that have too many dependencies.</p> <p>So how much work is it to make external functions available through <code class="language-plaintext highlighter-rouge">Imports</code>? The <code class="language-plaintext highlighter-rouge">usethis</code> package has a helpful function <code class="language-plaintext highlighter-rouge">use_import_from</code> that will take care of the bookkeeping in <code class="language-plaintext highlighter-rouge">DESCRIPTION</code> and <code class="language-plaintext highlighter-rouge">NAMESPACE</code>. The problem is that you now have to <em>manually call <code class="language-plaintext highlighter-rouge">use_import_from</code> for every external function in your package</em>. If you, like me, had a large codebase with mandatory dependencies, this is a boring process of running your code, seeing where it fails, adding an import, running again, and so on until you are almost-but-not-100%-sure that you imported everything correctly.</p> <h2 id="issue-4-all-your-rs-have-to-live-in-one-folder">Issue 4: All your .R’s have to live in one folder</h2> <p>Ok so you’ve done quite a bit of refactoring already. At this point you can probably <code class="language-plaintext highlighter-rouge">devtools::install</code> your package and do some proper testing. But, you may find that some of your own functions are not available. Why is this? In my case, it came down to the directory structure of the package. R packages have a mandatory structure. At minimum, an R package contains the following:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.
├── DESCRIPTION
├── NAMESPACE
├── LICENSE
└── R/
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">DESCRIPTION</code>, <code class="language-plaintext highlighter-rouge">NAMESPACE</code>, and <code class="language-plaintext highlighter-rouge">LICENSE</code> are fairly standard boilerplate files that can be auto-generated by the <code class="language-plaintext highlighter-rouge">devtools</code> package. Nothing too bad there. We hit a problem with the <code class="language-plaintext highlighter-rouge">R/</code> directory. This folder contains all of your files containing R code and <em>it is not allowed to have any subdirectories</em>. <a href="https://github.com/tidyverse/ggplot2/tree/main/R">No, really.</a>. A slightly amusing implication: <code class="language-plaintext highlighter-rouge">aaa.R</code> and <code class="language-plaintext highlighter-rouge">zzz.R</code> are conventionally used for hiding miscellaneous code that helps a package function so that they are easy to find in a directory. It definitely isn’t my place to comment on whether this was a good design choice. It is my place to argue that not allowing subfolders is a difference in convention between R users and R package developers that slows down package development. This also prevents developers from using submodules, like in Python, that encourage modular programming.</p> <p>Of all the issues here, this is perhaps the easiest one to fix. Simply dump all your files in R, make your filenames a little better, and you will be good to go.</p> <h2 id="conclusion-use-notebooks">Conclusion: Use notebooks</h2> <p>All told I spent <a href="https://github.com/s-kganz/LeafTemperature/pull/1">about a week refactoring</a> my project into an R package. Was it worth it? Probably not. The package barely works and I don’t plan on submitting it to CRAN. Does the package reproduce my science? Sure, if someone is motivated enough to get everything working.</p> <p>So if R packages are not the best vehicle for reproducibility, is there a better alternative? In my opinion, R notebooks <em>with the addition of functions in external files</em> are the best way to make your analysis reproducible. I have been skeptical of R notebooks because RStudio encourages you to knit them to another file format at the end of your analysis. This knitting process often brings up additional issues unrelated to the content of the notebook. Also, the development environment for R notebooks is seriously lacking. In RStudio only about 1/4 of the screen space is occupied by the notebook editor pane, results disappear when a code chunk is modified but not rerun, markdown chunks have to be rendered by the knitting process, and R objects are not displayed in a human-readable format by default (necessitating packages like <code class="language-plaintext highlighter-rouge">kable</code>). By contrast to the Python community, Jupyter Lab dedicates the whole screen to the notebook, results persist even when code is modified or rearranged, you can seamlessly toggle between raw and rendered markdown without having to go through a knitting process, and Python objects “know” how to display nicely in notebook format (e.g. <code class="language-plaintext highlighter-rouge">DataFrames</code>). Part of why Jupyter notebooks are so popular is that they blend the IDE with the finished product. R notebooks, in their current state, do not do this.</p> <p>Why are R notebooks the best option available despite these disadvantages? At least two alternatives, writing a package and sending someone your Git repo full of .R files, are much worse. You don’t have to follow rules about namespaces, so <code class="language-plaintext highlighter-rouge">library()</code> and <code class="language-plaintext highlighter-rouge">source()</code> are right at home in the notebook format and, by extension, you can spread any external files across subdirectories however you so choose and get at their functions with <code class="language-plaintext highlighter-rouge">source()</code>. Not everything has to be a function; R notebooks encourage the sketchpad-style of development that is endemic to standalone scripts. And even if you have to deal with the knitting process, notebooks capture output such that your work can be reproduced.</p> <p>TL;DR: is writing an R package to document research results worth it? No, unless you think your project will evolve into a tool. For documenting result, a notebook is your best bet.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Perhaps, but only if you want to put in the effort]]></summary></entry><entry><title type="html">A leaf energy-balance model from LiDAR and flux tower data</title><link href="https://s-kganz.github.io/agu23/" rel="alternate" type="text/html" title="A leaf energy-balance model from LiDAR and flux tower data"/><published>2023-11-25T00:00:00+00:00</published><updated>2023-11-25T00:00:00+00:00</updated><id>https://s-kganz.github.io/agu23</id><content type="html" xml:base="https://s-kganz.github.io/agu23/"><![CDATA[<blockquote> <p>This post describes the methods used to generate data presented at the 2023 AGU Fall Meeting. However, this project is a work in progress. Assumptions, simplifications, and approaches described here are <strong>not</strong> necessarily representative of later iterations of this work.</p> </blockquote> <h2 id="introduction">Introduction</h2> <p>Temperature is the ultimate biophysical parameter. The thermal environment of a plant drives respiration, photosynthesis, and transpiration rates<d-cite key="stillThermalImagingPlant2019"></d-cite>. There has been renewed interest in the temperature of forest canopies to quantify how environmental factors drive these processes<d-cite key="stillNoEvidenceCanopyscale2022"></d-cite><d-cite key="kiblerEvapotranspirationRegulatesLeaf2023"></d-cite>. However, most studies only consider the canopy top. The vertical heterogeneity of forests<d-cite key="vinodThermalSensitivityForest2023"></d-cite> drives vertical gradients in leaf temperature<d-cite key="garenCanopytopMeasurementsNot2023"></d-cite>, however, these gradients are not well-quantified.</p> <p>In this project, we sought to answer two questions:</p> <ul> <li>How do the drivers of canopy temperature differ across vertical strata?</li> <li>Under what conditions is canopy temperature diagnostic of plant drought stress?</li> </ul> <p>To answer these questions, we identified nine evergreen forests in the United States and used energy balance modeling to estimate canopy temperature from colocated aerial LiDAR and eddy covariance flux tower micrometeorology. We then validated our model against radiometers mounted at multiple vertical strata for each site. Our data indicate that across a range of climates, growth forms, and canopy structures, leaf temperature is warmer than air in the upper canopy and cooler than air in the lower canopy. Variation in canopy temperature is driven almost completely by air temperature, but variation in the leaf-air temperature difference is driven by stomatal conductance.</p> <h2 id="site-selection">Site selection</h2> <p>We selected study locations from the National Ecological Observatory Network (NEON) which met the following conditions:</p> <ul> <li>Canopy temperature radiometers in at least two different vertical positions.</li> <li>International Geosphere-Biosphere Programme vegetation class equal to ENF (evergreen needleleaf forest).</li> </ul> <p>This initial search yielded 11 sites. Two (YELL/US-xYE and SOAP/US-xSP) were excluded after analysis of radiometer position and view angle indicated that the radiometers at each site were viewing grasses, not tree canopies. The nine remaining sites are listed in the table below. The canopy heights below differ slightly from NEON metadata because we calculated canopy height from LiDAR returns in the immediate vicinity of each flux tower (see below).</p> <table> <thead> <tr> <th>Site name</th> <th>Ameriflux ID</th> <th>NEON ID</th> <th style="text-align: right">Latitude</th> <th style="text-align: right">Longitude</th> <th style="text-align: right">Tower height (m)</th> <th style="text-align: right">Canopy height (m)</th> </tr> </thead> <tbody> <tr> <td>Abby Road</td> <td>US-xAB</td> <td>ABBY</td> <td style="text-align: right">45.7624</td> <td style="text-align: right">-122.3303</td> <td style="text-align: right">20</td> <td style="text-align: right">13.5</td> </tr> <tr> <td>Caribou Creek</td> <td>US-xBN</td> <td>BONA</td> <td style="text-align: right">65.1540</td> <td style="text-align: right">-147.5026</td> <td style="text-align: right">19.5</td> <td style="text-align: right">6.5</td> </tr> <tr> <td>Delta Junction</td> <td>US-xDJ</td> <td>DEJU</td> <td style="text-align: right">63.8811</td> <td style="text-align: right">-145.7514</td> <td style="text-align: right">22.5</td> <td style="text-align: right">10</td> </tr> <tr> <td>Jones Ecological Research Center</td> <td>US-xJE</td> <td>JERC</td> <td style="text-align: right">31.1948</td> <td style="text-align: right">-84.4686</td> <td style="text-align: right">47</td> <td style="text-align: right">42.5</td> </tr> <tr> <td>Rocky Mountain National Park</td> <td>US-xRM</td> <td>RMNP</td> <td style="text-align: right">40.2759</td> <td style="text-align: right">-105.5459</td> <td style="text-align: right">25.5</td> <td style="text-align: right">17</td> </tr> <tr> <td>Ordway-Swisher Biological Station</td> <td>US-xSB</td> <td>OSBS</td> <td style="text-align: right">29.6893</td> <td style="text-align: right">-81.9934</td> <td style="text-align: right">35.5</td> <td style="text-align: right">21</td> </tr> <tr> <td>Talladega National Forest</td> <td>US-xTA</td> <td>TALL</td> <td style="text-align: right">32.9505</td> <td style="text-align: right">-87.3933</td> <td style="text-align: right">35.5</td> <td style="text-align: right">23.5</td> </tr> <tr> <td>Lower Teakettle</td> <td>US-xTE</td> <td>TEAK</td> <td style="text-align: right">37.0058</td> <td style="text-align: right">-119.0060</td> <td style="text-align: right">59</td> <td style="text-align: right">26</td> </tr> <tr> <td>Wind River Experimental Forest</td> <td>US-xWR</td> <td>WREF</td> <td style="text-align: right">45.8205</td> <td style="text-align: right">-121.9519</td> <td style="text-align: right">74</td> <td style="text-align: right">58</td> </tr> </tbody> </table> <h3 id="data-sources">Data sources</h3> <p>We acquired aerial LiDAR point clouds and ancillary NEON products through the <code class="language-plaintext highlighter-rouge">neonUtilities</code> R package<d-cite key="lunchNeonUtilitiesUtilitiesWorking2023"></d-cite>. For each site, we downloaded the most recent LiDAR acquisition (product ID <a href="https://data.neonscience.org/data-products/DP1.30003.001">DP1.30003.001</a>) within a 50 m buffer centered on the flux tower. We then normalized each point cloud with k-nearest neighbor inverse distance weighting in the <code class="language-plaintext highlighter-rouge">lidR</code> R package <d-cite key="rousselLidRPackageAnalysis2020"></d-cite>. Points less than 1 m above the ground surface were discarded for compatibility with leaf area index calculation (see below).</p> <p>We acquired flux tower micrometeorology data through the <code class="language-plaintext highlighter-rouge">amerifluxR</code> R package <d-cite key="chuAmerifluxrInterfaceAmeriFlux2022"></d-cite>. This package provides an API to download the <code class="language-plaintext highlighter-rouge">BASE-BADM</code> product for all sites in the NEON network. Although these data are not processed through the ONEFlux pipeline<d-cite key="pastorelloFLUXNET2015DatasetONEFlux2020"></d-cite>, we found the <code class="language-plaintext highlighter-rouge">BASE-BADM</code> product a more convenient way to access all instrumentation on the tower to reconstruct vertical profiles of meteorological variables. Data were filtered using the default parameters in the <code class="language-plaintext highlighter-rouge">amf_filter_base</code> function. For each variable, we determined its measurement height using the table returned by <code class="language-plaintext highlighter-rouge">amf_var_info</code> as of 14 November 2023.</p> <p>Our micrometeorology dataset served two purposes. First, observations of air temperature, wind speed, etc. were key driving variables in the leaf energy balance model. Second, observations of canopy temperature served as a validation dataset for our model. We note that tower observations of canopy temperature are measured by wide-angle radiometers that can be several meters away from foliage. Thus, non-leaf elements (branches, soil, grasses, metal infrastructure, etc.) can contaminate the radiometer signal. We mitigated this issue by discarding observations with a measurement height less than 1 m.</p> <h2 id="model-overview">Model overview</h2> <p>Energy balance models estimate leaf temperature by equating incoming and outgoing sources of radiation. We adopted the leaf-level model in <d-cite key="stillNoEvidenceCanopyscale2022"></d-cite>, parameterized for needle leaves. We acknowledge a scale mismatch with this choice: the model is developed for individual leaves, but we apply it to describe collections of leaves in a forest canopy. However, this model offers two key advantages that justify this choice. First, the model is computationally efficient in that it solves for canopy temperature directly without numerical optimization. Second, the model provides an additional output in the decoupling coefficient \(\Omega\), which gives further context on drivers of latent heat flux. For brevity, we do not repeat the entire model specification here. Given that needle leaves are often very well coupled with air temperature<d-cite key="kimThermalInfraredImaging2018"></d-cite><d-cite key="stillNoEvidenceCanopyscale2022"></d-cite>, it is instructive to focus on the leaf-air temperature difference (\(\Delta T\)):</p> \[\Delta T \propto R_n - \lambda E\] <p>where \(R_n\) is net isothermal radiation and \(\lambda E\) is latent heat flux. Due to high boundary layer conductance, \(\lambda E\) is driven by leaf stomatal conductance (\(g_s\)). Overall energy balance is therefore driven by two submodels of \(R_n\) and \(g_s\).</p> <h2 id="net-radiation-submodel">Net radiation submodel</h2> <p>\(R_n\) was calculated as</p> \[R_n = \alpha(\mathrm{SW \downarrow} - \mathrm{SW \uparrow}) + \epsilon(\mathrm{LW \downarrow} - \mathrm{LW \uparrow}) - \epsilon \sigma T_a^4\] <p>where \(\mathrm{SW}\) and \(\mathrm{LW}\) are fluxes of shortwave and longwave radiation, respectively, arrows indicate direction of flux (downwelling vs. upwelling), \(\alpha\) is shortwave reflectance of the leaf surface, \(\epsilon\) is leaf emissivity, \(\sigma\) is the Stefan-Boltzmann constant, and \(T_a\) is air temperature. Our micrometeorology dataset provided top-of-canopy measurements for each radiation flux, a vertical profile of air temperature, and a vertical profile of photosynthetically-active radiation (PAR). We made the following assumptions:</p> <ul> <li>\(\epsilon = 0.95\).</li> <li>\(\alpha = 0.50\).</li> <li>The ratio of downwelling to upwelling radiation was constant throughout the canopy.</li> <li>The downwelling longwave radiation flux was constant throughout the canopy.</li> <li>The vertical PAR profile was representative of all shortwave radiation, and that PAR (\(\mu\)mol m\(^{-2}\) s\(^{-1}\)) \(\approx 2.3 \times\) shortwave flux (W m\(^{-2}\) s\(^{-1}\)).</li> </ul> <p>We acknowledge the limitations of these assumptions and intend to revise these in future iterations of the model. Under these assumptions, we are tasked with calculating \(\mathrm{SW\downarrow}\) on a vertical profile from PAR sensors. We calculated the proportion of top-of-canopy shortwave radiation at vertical strata according to <d-cite key="starkAmazonForestCarbon2012"></d-cite>. In this approach, the LiDAR point cloud is partitioned into horizontal slices of constant thickness (in our case 1 m). For each slice, leaf area density (LAD) is calculated as</p> \[\mathrm{LAD}_z = \ln \frac{S_{z,in}}{S_{z,out}} \frac{1}{k \Delta z}\] <p>where \(S_{in}\) and \(S_{out}\) are the number of laser pulses entering and exiting the slice, respectively, \(\Delta z\) is slice thickness, and \(k\) is a calibration constant such that the sum of LAD is equal to leaf area index. The proportion of top-of-canopy radiation at height \(z\) is then calculated as</p> \[\frac{I_z}{I_o} = \exp(-k_I \sum_{i=0}^z \mathrm{LAD}_i \Delta z)\] <p>where \(k_I\) is an additional calibration constant and \(i=0\) corresponds to the canopy top. Note that \(\Delta z\) cancels out when the two equations above are combined. Therefore, once values for \(k\) and \(k_I\) are known, \(\frac{I_z}{I_o}\) can be calculated for any vertical position in the canopy.</p> <h3 id="model-calibration">Model calibration</h3> <p>Values of whole-canopy leaf area index are required to calibrate \(k\), while vertical profiles of light availability are required to calibrate \(k_I\). To determine leaf area index, (LAI) we utilized digital hemispherical photographs (DHPs) available through the NEON data portal (product ID <a href="https://data.neonscience.org/data-products/DP1.10017.001">DP1.10017.001</a>). DHPs are collected in the footprint of the flux tower at roughly shoulder height. Thus, the LAI values we calculate are a site average instead and ignore understory foliage. For each site, we randomly selected 10 DHPs per year and estimated LAI with the <code class="language-plaintext highlighter-rouge">hemispheR</code> R package <d-cite key="chianucciHemispheRPackageFisheye2023"></d-cite>. Precise fisheye lens parameters are not provided in NEON documentation, but based on mention of brand names we assumed that a Nikon Nikkor 10.5 mm fisheye lens was an appropriate assumption supported by <code class="language-plaintext highlighter-rouge">hemispheR</code>. No trends in LAI were observed over observation years, so we calculated site LAI as the median of all images processed. With site LAI known, we then calibrated \(k\) such that the sum of LAD along a vertical profile was equal to site LAI.</p> <p>We used photosynthetically-active radiation (PAR) sensors on each flux tower to determine an appropriate value for \(k_I\). Sensors are placed at multiple heights, allowing us to determine \(k_I\) as the slope of \(\log(I_z / I_o)\) vs. cumulative LAI. We calculated \(\log(I_z / I_o)\) as the geometric mean of all observations at each measurement height.</p> <h2 id="latent-heat-flux-submodel">Latent heat flux submodel</h2> <p>\(\lambda E\) was calculated as</p> \[\lambda E = \Omega \lambda E_{eq} + (1 - \Omega) \lambda E_{imp}.\] <p>This parameterization models \(\lambda E\) as the combination of radiation-limited (\(\lambda E_{eq}\)) and stomatally-imposed (\(\lambda E_{imp}\)) endpoints, related by the decoupling coefficient \(\Omega\). We refer the reader to <d-cite key="stillNoEvidenceCanopyscale2022"></d-cite> for complete details on calculation of these variables. Generally, leaf temperature was well-coupled with air (\(\Omega \approx 0\)), so \(\lambda E \approx \lambda E_{imp}\). This endpoint is calculated as</p> \[\lambda E_{imp} = g_{tot} \frac{D}{P_a}\] <p>where \(g_{tot}\) is the reciprocal sum of leaf boundary layer conductance (\(g_{bH}\)) and stomatal conductance (\(g_s\)), \(D\) is vapor pressure deficit, and \(P_a\) is air pressure. Leaf boundary layer conductance was typically much higher than stomatal conductance, so \(g_{tot} \approx g_s\). Air pressure and vapor pressure deficit could be calculated directly from tower instrumentation. Therefore, this submodel is primarily concerned with estimating \(g_s\).</p> <p>We estimated \(g_s\) on a vertical profile by downscaling canopy-scale \(g_s\) with our micrometeorological data via a linear mixed effects model. To do so, we first developed a dataset of canopy-scale \(g_s\). Canopy-scale \(g_s\) is estimated from total latent heat flux, but this method is meaningful only when total evapotranspiration is driven by plant transpiration (i.e. \(T/ET \approx 1\)). We filtered latent heat flux observations to those without rainfall in the prior 72 hours to ensure the latent heat flux was dominated by transpiration. We then used the R package <code class="language-plaintext highlighter-rouge">bigleaf</code><d-cite key="knauerBigleafPackageCalculation2018a"></d-cite> to calculate canopy-scale \(g_s\) with the function <code class="language-plaintext highlighter-rouge">surface.conductance</code>. Then, we divided canopy-scale \(g_s\) by average site LAI to get an estimate of average leaf \(g_s\) throughout the canopy. We discarded the top 5% of \(g_s\) values at each site since these were physically unreasonable. We then fit a linear mixed effects model with the R package <code class="language-plaintext highlighter-rouge">lme4</code><d-cite key="batesFittingLinearMixedEffects2015a"></d-cite> to estimate leaf-level \(g_s\) as a function of air temperature, downwelling shortwave radiation, and vapor pressure deficit. This approach enabled us to effectively downscale canopy-scale conductance values to vertical strata within the canopy.</p> <p>Selecting the appropriate fixed and random effects for a linear mixed effects model is complicated by large sample sizes. Typically, metrics such as the Akaike or Bayesian information criterion are used to rank different model forms. These criteria select for models that fit data well and against models with many parameters. In our situation, a large sample size (\(n = 25,579\) across all sites) meant that very small improvements in model fit outpaced the penalty associated with model complexity. Thus, information criteria were not useful in selecting a model form. Instead, we fit fixed slopes across all sites and random slopes and intercepts for VPD at each site. In R formula format, the final model took the following form.</p> \[g_s \sim T_a + \mathrm{SW\downarrow} + \mathrm{VPD} + (\mathrm{VPD} | \mathrm{site})\] <h2 id="future-work">Future work</h2> <p>Current data indicate that our approach to downscaling canopy-scale \(g_s\) does not accurately represent variation in latent heat flux throughout the canopy. With our current methods, cooling from latent heat is relatively constant on a vertical profile. One avenue to improve this limitation is to couple photosynthesis and stomatal conductance as prior authors have <d-cite key="stillNoEvidenceCanopyscale2022"></d-cite>. This presents a new challenge in attributing canopy-scale photosynthesis to vertical strata.</p> <p>Our approach to modeling longwave radiation is also quite limited. Longwave radiation data are only available at the top of the canopy, so we cannot derive extinction coefficients as we do for shortwave radiation. If an analytical or empirical relationship with LAI is not known, we may simply retrieve reasonable estimates from the literature.</p>]]></content><author><name>Keenan Ganz</name></author><summary type="html"><![CDATA[Detailed methods for my iPoster at AGU 2023.]]></summary></entry><entry><title type="html">Animating LiDAR point clouds in R</title><link href="https://s-kganz.github.io/blog/2023/animate-lidar/" rel="alternate" type="text/html" title="Animating LiDAR point clouds in R"/><published>2023-09-21T00:00:00+00:00</published><updated>2023-09-21T00:00:00+00:00</updated><id>https://s-kganz.github.io/blog/2023/animate-lidar</id><content type="html" xml:base="https://s-kganz.github.io/blog/2023/animate-lidar/"><![CDATA[<p>Recently I gave a brief presentation at <a href="https://cugos.org/">CUGOS</a> about some LiDAR animations I’ve been working on. There was a fair amount of ooh and aah (if I do say so myself), so this post is a brief how-to of how to animate LiDAR data in R. As an example, here is an animation of downwelling radiation in a forest canopy during a typical day in August.</p> <iframe width="560" height="315" src="https://www.youtube.com/embed/zl5cQ7XOIA4?si=Rcz9jzTHTYIZ6Ewn" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""> </iframe> <p>I started working on this because I was taking a LiDAR cloud, which is already 3-dimensional, and adding a temporal dimension with data from the flux tower in Wind River Experimental Forest. Visualizing 4-dimensions statically is really hard, and animations are really pretty anyway.</p> <p>I’m going to assume that you have basic knowledge of working with LiDAR data in R. If not, I highly recommend the <a href="https://r-lidar.github.io/lidRbook/">lidR book</a> and <a href="https://www.neonscience.org/resources/learning-hub/tutorials/create-chm-rasters-r">this tutorial</a> from NSF NEON. We aren’t going to use any of the processing features in <code class="language-plaintext highlighter-rouge">lidR</code>, so if you know how to plot a cloud with it you are good to go. Also, this approach only works well with small clips of airborne LiDAR. If you have a huge dataset, <code class="language-plaintext highlighter-rouge">rgl</code> will really struggle.</p> <h2 id="setup">Setup</h2> <p>There are three key packages: <code class="language-plaintext highlighter-rouge">lidR</code>, <code class="language-plaintext highlighter-rouge">rgl</code>, and <code class="language-plaintext highlighter-rouge">rglplus</code>. <code class="language-plaintext highlighter-rouge">lidR</code> is the most popular R package for reading and manipulating LiDAR data, while <code class="language-plaintext highlighter-rouge">rgl</code> and <code class="language-plaintext highlighter-rouge">rglplus</code> provide 3D visualization utilities.</p> <p>We generate animations with the function <code class="language-plaintext highlighter-rouge">rglplus::rgl.makemovie</code>. This function calls ffmpeg under the hood to convert a series of image files into an MP4 video. You will need to have ffmpeg installed <em>and accessible from the RStudio terminal</em> for this to work. If you don’t have that for some reason, <code class="language-plaintext highlighter-rouge">rgl.makemovie</code> will generate a directory of image files for each frame of the animation. You can then encode all of those into a video with the tool of your choice.</p> <p>With all that said, let’s build the structure of our first animation.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">lidR</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rgl</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rglplus</span><span class="p">)</span><span class="w">

</span><span class="c1"># Toy data included with lidR</span><span class="w">
</span><span class="n">LASfile</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">system.file</span><span class="p">(</span><span class="s2">"extdata"</span><span class="p">,</span><span class="w"> </span><span class="s2">"MixedConifer.laz"</span><span class="p">,</span><span class="w"> </span><span class="n">package</span><span class="o">=</span><span class="s2">"lidR"</span><span class="p">)</span><span class="w">
</span><span class="n">las</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readLAS</span><span class="p">(</span><span class="n">LASfile</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>The way we generate animations is with <code class="language-plaintext highlighter-rouge">rglplus::rgl.makemovie</code>. This function works by effectively taking a screenshot of the active rgl scene, and then concatenating all of those together in an MP4 video using ffmpeg. Fortunately for us, <code class="language-plaintext highlighter-rouge">lidR::plot</code> uses rgl as its backend, so we can easily pair those two together. The most important argument to <code class="language-plaintext highlighter-rouge">rgl.makemovie</code> is <code class="language-plaintext highlighter-rouge">frame</code>. <code class="language-plaintext highlighter-rouge">frame</code> is a function of one argument that updates the current rgl context before the next frame of the animation is captured.</p> <p>To start with, we are just going to plot the point cloud and add some text indicating the current frame time. Call the function and you should see the cloud with some text, like so.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_frame_func</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">close3d</span><span class="p">()</span><span class="w">            </span><span class="c1"># Close the current scene if one exists</span><span class="w">
  </span><span class="n">plot</span><span class="p">(</span><span class="n">las</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w"> </span><span class="c1"># Plot the point cloud</span><span class="w">
  </span><span class="n">display_t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.character</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">))</span><span class="w">
  </span><span class="n">text3d</span><span class="p">(</span><span class="m">40</span><span class="p">,</span><span class="w"> </span><span class="m">40</span><span class="p">,</span><span class="w"> </span><span class="m">60</span><span class="p">,</span><span class="w"> </span><span class="n">display_t</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="o">=</span><span class="s2">"white"</span><span class="p">)</span><span class="w"> </span><span class="c1"># add text at the point (40, 40, 60)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_frame_func</span><span class="p">(</span><span class="m">0.5</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p><img src="/assets/img/example-frame-1.png" alt=""/></p> <p>Now let’s call this function with <code class="language-plaintext highlighter-rouge">rgl.makemovie</code>.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">anim_time</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="n">fps</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">30</span><span class="w">
</span><span class="n">out_dir</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tempdir</span><span class="p">()</span><span class="w">

</span><span class="n">rgl.makemovie</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">my_frame_func</span><span class="p">,</span><span class="w"> </span><span class="n">tmin</span><span class="o">=</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">tmax</span><span class="o">=</span><span class="n">anim_time</span><span class="p">,</span><span class="w"> </span><span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">nframes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anim_time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">output.path</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span><span class="w">
              </span><span class="n">output.filename</span><span class="o">=</span><span class="s2">"my_movie1.mp4"</span><span class="p">,</span><span class="w">
              </span><span class="n">quiet</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>You should see a bunch of output, and a series of rgl windows opening and closing quickly. In the above, I’m writing the output to a temporary directory. If you open that directory, you should see a file called <code class="language-plaintext highlighter-rouge">my_movie.mp4</code>. Open the video, and you should see a simple render of your point cloud and some white text that goes from 0 to 1. Now let’s build from this.</p> <h2 id="3d-visualization-parameters">3D visualization parameters</h2> <p><code class="language-plaintext highlighter-rouge">rgl</code> gives us several ways to play with the camera and window size that are exposed through the function <code class="language-plaintext highlighter-rouge">par3d</code>. This function returns a named list with all the grahpics settings of the current scene. Plot up the point cloud and then call this function.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">las</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">par3d</span><span class="p">()</span><span class="w">
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $antialias
## [1] 8
## 
## $FOV
## [1] 30
## 
## $ignoreExtent
## [1] FALSE
## 
## $listeners
## [1] 472
## 
## $mouseMode
##        none        left       right      middle       wheel 
##      "none" "trackball"      "user"       "fov"      "pull" 
## 
## $observer
## [1]   0.000   0.000 253.424
## 
## $modelMatrix
##      [,1]       [,2]      [,3]       [,4]
## [1,]    1  0.0000000 0.0000000  -44.99500
## [2,]    0  0.3420202 0.9396926  -30.44178
## [3,]    0 -0.9396926 0.3420202 -216.66910
## [4,]    0  0.0000000 0.0000000    1.00000
## 
## $projMatrix
##          [,1]     [,2]      [,3]      [,4]
## [1,] 3.732051 0.000000  0.000000    0.0000
## [2,] 0.000000 3.732051  0.000000    0.0000
## [3,] 0.000000 0.000000 -3.863703 -913.5641
## [4,] 0.000000 0.000000 -1.000000    0.0000
## 
## $skipRedraw
## [1] FALSE
## 
## $userMatrix
##      [,1]       [,2]      [,3] [,4]
## [1,]    1  0.0000000 0.0000000    0
## [2,]    0  0.3420201 0.9396926    0
## [3,]    0 -0.9396926 0.3420201    0
## [4,]    0  0.0000000 0.0000000    1
## 
## $userProjection
##      [,1] [,2] [,3] [,4]
## [1,]    1    0    0    0
## [2,]    0    1    0    0
## [3,]    0    0    1    0
## [4,]    0    0    0    1
## 
## $scale
## [1] 1 1 1
## 
## $viewport
##      x      y  width height 
##      0      0    256    256 
## 
## $zoom
## [1] 1
## 
## $bbox
## [1]  0.00 89.99  0.00 89.90  0.00 32.07
## 
## $windowRect
## [1] 138 161 394 417
## 
## $family
## [1] "sans"
## 
## $font
## [1] 1
## 
## $cex
## [1] 1
## 
## $useFreeType
## [1] FALSE
## 
## $fontname
## [1] "TT Arial"
## 
## $maxClipPlanes
## [1] 8
## 
## $glVersion
## [1] 4.6
## 
## $activeSubscene
## [1] 0
</code></pre></div></div> <p>There’s a lot going on here, most of which we don’t really care about. Reading the documentation is a good place to start understanding what all this means, but it is also helpful to play with the cloud and then call <code class="language-plaintext highlighter-rouge">par3d</code> again. Resize the window, then <code class="language-plaintext highlighter-rouge">viewport</code> and <code class="language-plaintext highlighter-rouge">windowRect</code> change. Click and drag the cloud, then <code class="language-plaintext highlighter-rouge">userMatrix</code> and <code class="language-plaintext highlighter-rouge">modelMatrix</code> change. There are 4 parameters we care about: <code class="language-plaintext highlighter-rouge">userMatrix</code>, <code class="language-plaintext highlighter-rouge">userProjection</code>, <code class="language-plaintext highlighter-rouge">windowRect</code>, and <code class="language-plaintext highlighter-rouge">scale</code>.</p> <p>This gives us a way to set up a window size and view angle and then apply it to an animation. Try changing the scene around, then save the parameters in a list. We can then supply this to <code class="language-plaintext highlighter-rouge">par3d</code> in our frame function. One important detail is that the <strong>window size must be divisible by 2 for the conversion to MP4 to work</strong>.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># After moving the cloud around...</span><span class="w">
</span><span class="n">mypar</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">par3d</span><span class="p">()[</span><span class="nf">c</span><span class="p">(</span><span class="s2">"userMatrix"</span><span class="p">,</span><span class="w"> </span><span class="s2">"userProjection"</span><span class="p">,</span><span class="w">
                   </span><span class="s2">"windowRect"</span><span class="p">,</span><span class="w"> </span><span class="s2">"scale"</span><span class="p">)]</span><span class="w">

</span><span class="c1"># Make sure the window size is divisible by 2</span><span class="w">
</span><span class="n">mypar</span><span class="o">$</span><span class="n">windowRect</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span><span class="n">mypar</span><span class="o">$</span><span class="n">windowRect</span><span class="o">/</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">2</span><span class="w">

</span><span class="n">my_frame_func2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1"># Same as before...</span><span class="w">
  </span><span class="n">my_frame_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w">
  </span><span class="c1"># Except now we set the new view parameters</span><span class="w">
  </span><span class="n">par3d</span><span class="p">(</span><span class="n">mypar</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">rgl.makemovie</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">my_frame_func2</span><span class="p">,</span><span class="w"> </span><span class="n">tmin</span><span class="o">=</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">tmax</span><span class="o">=</span><span class="n">anim_time</span><span class="p">,</span><span class="w"> </span><span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">nframes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anim_time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">output.path</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span><span class="w">
              </span><span class="n">output.filename</span><span class="o">=</span><span class="s2">"my_movie2.mp4"</span><span class="p">,</span><span class="w">
              </span><span class="n">quiet</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>Now you should get a new animation with the camera and window size adjusted like before. Next, we will learn how to manipulate the point cloud within the scene.</p> <h2 id="rotating-the-cloud">Rotating the cloud</h2> <p>If we want the point cloud to move within our scene, we have two options: move the camera, or move the point cloud. In my experience I find moving the point cloud easier. But, you could also accomplish this by modifying <code class="language-plaintext highlighter-rouge">userMatrix</code> and <code class="language-plaintext highlighter-rouge">observer</code> with <code class="language-plaintext highlighter-rouge">par3d</code>.</p> <p>At its core, LiDAR data is just a matrix of points in 3D space. The <code class="language-plaintext highlighter-rouge">lidR</code> package lets us access that data through the <code class="language-plaintext highlighter-rouge">$data</code> slot. To rotate points in 3D space, we turn to <a href="https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions">rotation matrices</a>. This can be a little tricky, so let’s start by just rotating our existing point cloud.</p> <p>Rotation matrices will spin points around the origin (0, 0, 0). But, if we check the data in our point cloud, we find that the points are far from the origin.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">las</span><span class="w">
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class        : LAS (v1.2 format 1)
## memory       : 2.2 Mb 
## extent       : 481260, 481350, 3812921, 3813011 (xmin, xmax, ymin, ymax)
## coord. ref.  : NAD83 / UTM zone 12N 
## area         : 8072 m²
## points       : 37.7 thousand points
## density      : 4.67 points/m²
## density      : 4.67 pulses/m²
</code></pre></div></div> <p>You can still do the rotation without accounting for the offset, but the result will be way off in space. So, really we have three steps.</p> <ol> <li>Center the original data at the origin</li> <li>Apply the rotation</li> <li>Re-offset the rotated data at the original position (if needed)</li> </ol> <p>Fortunately this is pretty easy since we can get the appropriate offset with the mean of each coordinate.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">offset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="w">
  </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">X</span><span class="p">),</span><span class="w">
  </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">Y</span><span class="p">),</span><span class="w">
  </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">Z</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">

</span><span class="c1"># Only grab the XYZ coordinates</span><span class="w">
</span><span class="n">las_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">]</span><span class="w"> 
</span><span class="c1"># Sweep subtracts a constant from each column</span><span class="w">
</span><span class="c1"># See https://stackoverflow.com/questions/24520720/subtract-a-constant-vector-from-each-row-in-a-matrix-in-r</span><span class="w">
</span><span class="n">las_data_center</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sweep</span><span class="p">(</span><span class="n">las_data</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="o">=</span><span class="s2">"-"</span><span class="p">)</span><span class="w"> 

</span><span class="c1"># Check that it worked - ranges are centered on zero</span><span class="w">
</span><span class="n">apply</span><span class="p">(</span><span class="n">las_data_center</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">range</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##              X         Y         Z
## [1,] -45.19922 -45.23283 -12.01463
## [2,]  44.79078  44.66717  20.05537
</code></pre></div></div> <p>With our data centered, we can now rotate it without messing up the coordinate space. First we make the rotation matrix. For more complex movements, you can also use <code class="language-plaintext highlighter-rouge">rgl::rotationMatrix</code>.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ~45 degrees in radians</span><span class="w">
</span><span class="n">theta</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0.785</span><span class="w">
</span><span class="c1"># Manually create the matrix</span><span class="w">
</span><span class="n">rot_mtx_y45</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">matrix</span><span class="p">(</span><span class="w">
  </span><span class="nf">c</span><span class="p">(</span><span class="w"> 
     </span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">  </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">
              </span><span class="m">0</span><span class="p">,</span><span class="w">  </span><span class="m">1</span><span class="p">,</span><span class="w">          </span><span class="m">0</span><span class="p">,</span><span class="w">
    </span><span class="o">-</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">  </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w">
  </span><span class="p">),</span><span class="w">
  </span><span class="n">nrow</span><span class="o">=</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="m">3</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>Then we apply the matrix to our centered data.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Make sure to use the matrix multiplication operator!</span><span class="w">
</span><span class="c1"># t() is the transpose function, it ensures the matrix dimensions</span><span class="w">
</span><span class="c1"># remain how we want them.</span><span class="w">
</span><span class="n">las_data_center_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">rot_mtx_y45</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">las_data_center</span><span class="p">))</span><span class="w"> 
</span></code></pre></div></div> <p>Next we reapply the offset so the rotated cloud is near the old one. You can ignore this step if you don’t care about having similar coordinates to the original, it won’t affect the animation result.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Do the reverse of the sweep call from before</span><span class="w">
</span><span class="n">las_data_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sweep</span><span class="p">(</span><span class="n">las_data_center_rotate</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="o">=</span><span class="s2">"+"</span><span class="p">)</span><span class="w">
</span><span class="c1"># Check that it worked again - ranges are similar to the original cloud.</span><span class="w">
</span><span class="n">apply</span><span class="p">(</span><span class="n">las_data_rotate</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">range</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##          [,1]    [,2]      [,3]
## [1,] 481265.5 3812921 -28.41818
## [2,] 481345.3 3813011  52.62642
</code></pre></div></div> <p>Finally, we rebuild the LAS object so we can plot it. Modifying the data slot directly like this can invalidate the internal LAS specification, preventing you from saving out the rotated data. But if you only care about animating then it’s whatever. If you know of a less hacky way, let me know :)</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">las_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las</span><span class="w">
</span><span class="n">las_rotate</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">]</span><span class="w">
</span><span class="n">las_rotate</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w">
</span><span class="n">las_rotate</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w">

</span><span class="n">plot</span><span class="p">(</span><span class="n">las_rotate</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p><img src="/assets/img/rot-example4-1.png" alt=""/></p> <p>And there you go, a point cloud on a slant. You may be asking yourself why on Earth you would ever need this. One example is modeling how light moves through a canopy. Sunlight almost never hits a forest canopy at nadir, and accounting for solar angle can be important in early morning or high-latitude environments.</p> <h2 id="bring-it-all-together">Bring it all together</h2> <p>Now let’s animate a spinning cloud. First, let’s functionalize some code.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rot_matrix_y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1"># Make a rotation matrix about the y axis</span><span class="w">
  </span><span class="n">matrix</span><span class="p">(</span><span class="w">
    </span><span class="nf">c</span><span class="p">(</span><span class="w"> 
       </span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">  </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">
                </span><span class="m">0</span><span class="p">,</span><span class="w">  </span><span class="m">1</span><span class="p">,</span><span class="w">          </span><span class="m">0</span><span class="p">,</span><span class="w">
      </span><span class="o">-</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="w">  </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w">
    </span><span class="p">),</span><span class="w">
    </span><span class="n">nrow</span><span class="o">=</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="m">3</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">rotate_las</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">las</span><span class="p">,</span><span class="w"> </span><span class="n">rot_mtx</span><span class="p">,</span><span class="w"> </span><span class="n">do_offset</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">do_offset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="w">
      </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">X</span><span class="p">),</span><span class="w">
      </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">Y</span><span class="p">),</span><span class="w">
      </span><span class="n">mean</span><span class="p">(</span><span class="n">las</span><span class="o">$</span><span class="n">Z</span><span class="p">)</span><span class="w">
    </span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="n">las_data_center</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sweep</span><span class="p">(</span><span class="n">las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">],</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="o">=</span><span class="s2">"-"</span><span class="p">)</span><span class="w">
  </span><span class="n">las_data_center_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">rot_mtx</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">las_data_center</span><span class="p">))</span><span class="w">
  </span><span class="n">las_data_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sweep</span><span class="p">(</span><span class="n">las_data_center_rotate</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="o">=</span><span class="s2">"+"</span><span class="p">)</span><span class="w">
  
  </span><span class="n">new_las</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las</span><span class="w">
  </span><span class="n">new_las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">]</span><span class="w">
  </span><span class="n">new_las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w">
  </span><span class="n">new_las</span><span class="o">@</span><span class="n">data</span><span class="p">[,</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">las_data_rotate</span><span class="p">[,</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w">
  
  </span><span class="n">new_las</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>Now we modify the frame function to rotate the cloud at an angle dependent on the animation time.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_frame_func3</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">close3d</span><span class="p">()</span><span class="w">
  </span><span class="c1"># Use the animation time as the rotation angle</span><span class="w">
  </span><span class="n">theta</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">t</span><span class="w"> 
  </span><span class="c1"># Rotate the cloud</span><span class="w">
  </span><span class="n">rot_mtx</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rot_matrix_y</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w">
  </span><span class="n">las_rotate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rotate_las</span><span class="p">(</span><span class="n">las</span><span class="p">,</span><span class="w"> </span><span class="n">rot_mtx</span><span class="p">)</span><span class="w">
  </span><span class="c1"># Plot everything else as before</span><span class="w">
  </span><span class="n">plot</span><span class="p">(</span><span class="n">las_rotate</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
  </span><span class="n">display_t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.character</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">))</span><span class="w">
  </span><span class="n">text3d</span><span class="p">(</span><span class="m">40</span><span class="p">,</span><span class="w"> </span><span class="m">40</span><span class="p">,</span><span class="w"> </span><span class="m">60</span><span class="p">,</span><span class="w"> </span><span class="n">display_t</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="o">=</span><span class="s2">"white"</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>And we should now get a video of a spinning point cloud. I’m changing the frame time and fps so it doesn’t take as long to animate.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">anim_time</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">6.28</span><span class="w"> </span><span class="c1"># get a full rotation</span><span class="w">
</span><span class="n">fps</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">15</span><span class="w">
</span><span class="n">rgl.makemovie</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">my_frame_func3</span><span class="p">,</span><span class="w"> </span><span class="n">tmin</span><span class="o">=</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">tmax</span><span class="o">=</span><span class="n">anim_time</span><span class="p">,</span><span class="w"> </span><span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">nframes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anim_time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fps</span><span class="p">,</span><span class="w">
              </span><span class="n">output.path</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span><span class="w">
              </span><span class="n">output.filename</span><span class="o">=</span><span class="s2">"my_movie3.mp4"</span><span class="p">,</span><span class="w">
              </span><span class="n">quiet</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <p>And there you have it. This only scratches the surface of what is feasible with <code class="language-plaintext highlighter-rouge">lidR</code> and <code class="language-plaintext highlighter-rouge">rgl</code>. We could just as easily compute something about the point cloud in each frame and modify the color ramp to represent that (I did exactly that in the example embedded at the start of this post) Although this approach is fairly hacky, there are not many open-source tools that let you build animations with LiDAR. The next best option, especially for large datasets, would probably be the animation plugin in CloudCompare (example <a href="https://www.youtube.com/watch?v=aqfoYPzqUoE">here</a>). However, that approach is not programmatic, does not allow editing the point color, and requires you to set key frames manually.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Animations with LidR and rgl]]></summary></entry><entry><title type="html">Geomorphons in Earth Engine</title><link href="https://s-kganz.github.io/blog/2023/geomorphons/" rel="alternate" type="text/html" title="Geomorphons in Earth Engine"/><published>2023-07-21T12:00:00+00:00</published><updated>2023-07-21T12:00:00+00:00</updated><id>https://s-kganz.github.io/blog/2023/geomorphons</id><content type="html" xml:base="https://s-kganz.github.io/blog/2023/geomorphons/"><![CDATA[<p>Let’s say I have an elevation map of a landscape, and I want to find all the hills. One way I might do this is by looking at each cell, and comparing its elevation with its neighbors. If the cell is higher up than its neighbors, it’s a hill. You can extend this idea to other landforms too. If the cell is lower than its neighbors, it’s a sink. If some cells are higher and others are lower, the cell might be on a hill. The core idea here is to classify each cell in a landscape by its relationship to its neighbors.</p> <p><a href="https://www.researchgate.net/publication/264850233_Geomorphons_-_A_new_approach_to_classification_of_landforms">Geomorphons</a> are an approach to exhaustively quantify every possible cell-neighbor relationship. In an elevation raster, consider a cell and its 8 neighbors. For each neighbor, encode the sign of the difference between the cell and its neighbor. We then have a string of 8 values, <code class="language-plaintext highlighter-rouge">-1</code>, <code class="language-plaintext highlighter-rouge">0</code>, or <code class="language-plaintext highlighter-rouge">1</code>, for each cell. The cell’s “geomorphon” is a ternary code made from the string.</p> <p>Looking at these codes, we can quickly see how they are related to landform type. If all neighbors are higher than the central cell, the geomorphon will just be <code class="language-plaintext highlighter-rouge">-1</code> 8 times. If all neighbors are shorter, then the string will be <code class="language-plaintext highlighter-rouge">1</code> 8 times. A slope will have a mixture of <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">0</code>, and <code class="language-plaintext highlighter-rouge">-1</code>. Flat spots will have more <code class="language-plaintext highlighter-rouge">0</code> than <code class="language-plaintext highlighter-rouge">1</code> or <code class="language-plaintext highlighter-rouge">-1</code>.</p> <p>With 8 ternary digits, we have \(3^8\) = 6,561 possible geomorphons. Not all of these are unique. By rotating or reflecting geomorphons, we can show that many of them are exactly the same. For example, consider the geomorphon <code class="language-plaintext highlighter-rouge">10000000</code>. One neighbor lower than the central cell, then all others at the same elevation. Now consider <code class="language-plaintext highlighter-rouge">01000000</code>. Although the two strings are unique, they are semantically equivalent. Even if 6,561 geomorphons are possible, we definitely want to merge some codes together.</p> <p>In a <a href="https://www.sciencedirect.com/science/article/pii/S0169555X12005028">later paper</a>, the same authors describe how to merge geomorphons into 10 possible classes based off of the number of <code class="language-plaintext highlighter-rouge">1</code>, or <code class="language-plaintext highlighter-rouge">-1</code> digits in the string. <a href="https://www.whiteboxgeo.com/manual/wbt_book/available_tools/geomorphometric_analysis.html#Geomorphons">WhiteboxTools</a> implements this approach, and I was curious if you can do it in Earth Engine too. Turns out, you can!</p> <p>The key idea here is to use kernel convolutions to compare a cell of an elevation raster with a neighboring cell. For example, say we want to find the sign of the difference between a cell \(x\) and its top-left neighbor, \(a\). To do so, we use a convolution to shift \(a\) into the position \(x\) was in.</p> \[\begin{bmatrix} a &amp; - &amp; - \\ - &amp; x &amp; - \\ - &amp; - &amp; - \end{bmatrix} * \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{bmatrix} = \begin{bmatrix} - &amp; - &amp; - \\ - &amp; a &amp; - \\ - &amp; - &amp; - \end{bmatrix}\] <p>Then we can easily subtract the convolved elevation raster from the original elevation raster and take the sign - that’s the first digit of the geomorphon. Repeat this process with the kernel rotated for the other neighbors and we get the ternary code. Then, count up the number of positive and negative signs and use a lookup table (Fig. 4 in the linked paper) to get the final landform classification.</p> <p>I’ve written an example script <a href="https://code.earthengine.google.com/8170da14a911359d65a423b1248c5dda">here</a> for the elevation image from the SRTM mission. But, this approach is image-agnostic and should work on whatever elevation model you have.</p> <p>Below is an example of the geomorphon classification near Mt. Rainier. Orange is flat cells, pink is ridges, and light green is ridges. When overlaid with a hillshade, you can see how the classifications correspond to real life features.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/morphons-480.webp 480w,/assets/img/morphons-800.webp 800w,/assets/img/morphons-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/morphons.png" class="img-fluid z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Identifying landform types in GEE]]></summary></entry><entry><title type="html">A tale of three leaf models</title><link href="https://s-kganz.github.io/blog/2023/leaf-temperature/" rel="alternate" type="text/html" title="A tale of three leaf models"/><published>2023-06-29T12:00:00+00:00</published><updated>2023-06-29T12:00:00+00:00</updated><id>https://s-kganz.github.io/blog/2023/leaf-temperature</id><content type="html" xml:base="https://s-kganz.github.io/blog/2023/leaf-temperature/"><![CDATA[<p>The temperature of a plant’s leaves is a really interesting parameter. Temperature is influenced by both things happening inside the plant (photosynthesis, respiration, etc.) and also the environment the plant is in (air temperature, humidity, downwelling radiation, etc.). In general, under constant environmental conditions a warmer plant is unhappier than a cooler plant. Healthy leaves are photosynthesizing and evaporating water. Evaporating water cools the leaf, so if that process is disrupted for some reason the leaf will warm up. If we measure a leaf’s temperature, we can have a general idea of whether the plant is happily photosynthesizing or experiencing some form of stress. But, here’s the problem. Outside of the laboratory, environmental conditions are never constant.</p> <p>When we measure a leaf’s temperature, how do we know whether that temperature is a good or a bad sign in that plant’s environment? A <a href="https://www.sciencedirect.com/science/article/pii/S0168192323002514">paper just came</a> out that uses flux tower data to answer this question, and I think the authors’ approach is worth focusing on. To understand why, let’s take a look at models of leaf temperature through time.</p> <h1 id="approach-1-empirical-models">Approach 1: Empirical models</h1> <p>The use of leaf temperature to model plants finds its roots in the 1980s. A group from the US Water Conservation Laboratory used the Penman-Monteith equation, an evapotranspiration model, to model water stress with leaf temperature. They developed an index called the crop water stress index (CWSI). Conceptually, the CWSI compared how much a leaf transpired compared to the maximum rate under the observed conditions.</p> <p>Unfortunately, the analytical version of this index was a little gnarly to calculate.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cwsi_analytic-480.webp 480w,/assets/img/cwsi_analytic-800.webp 800w,/assets/img/cwsi_analytic-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/cwsi_analytic.png" class="img-fluid z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>So, the same year that <a href="https://onlinelibrary.wiley.com/doi/abs/10.1029/WR017i004p01133">the original CWSI paper</a> was published, the same group came out with <a href="https://www.sciencedirect.com/science/article/pii/0002157181900327">an empirical version</a> that could be deployed in crop fields.</p> <p>This new version of the CWSI was much easier to use, but required more setup. Instead of modeling the maximum transpiration rate, the empirical CWSI compared the temperature of a given leaf to well-watered and water-stressed control plants. If the temperature of your field was closer to the water-stressed control, you could say that your crops are water stressed. And, if the temperature of the field was close to the well-watered control, you wcould say that your crops are not water stressed.</p> <p>The empirical CWSI has since been studied in dozens of plants with consistent success. Produce you eat may have been irrigated using guidance from a CWSI monitoring system. But, what if we work in a natural system where we cannot manipulate some plants to be stressed and others well-watered? In this case, we again have to turn to modeling.</p> <h1 id="approach-2-leaf-level-model">Approach 2: Leaf-level model</h1> <p>The second major approach to modeling leaf temperature is to consider the physics of heat transfer at the leaf level. These models generally assume energy balance, that is, the amount of energy entering a leaf is the same as the amount of energy exiting a leaf. The model will use a series of equations to describe heat transfer in the leaf which can then be solved for leaf temperature.</p> <p>A recent example of such an energy balance model is described in <a href="https://doi.org/10.1007/s11284-011-0905-5">Okajima et al. (2012)</a> and implemented in the R package <code class="language-plaintext highlighter-rouge">tealeaves</code>. I’ve also written <a href="http://ganzk.shinyapps.io/shiny_tealeaves">a Shiny application</a> to interact with the model.</p> <p>Although energy balance models have a sound physical basis, they require parameters that are difficult to measure. For example, the model implemented in <code class="language-plaintext highlighter-rouge">tealeaves</code> represents the transpiration rate of the leaf through two parameters: stomatal conductance and cuticular conductance. If I want to know the temperature of a non-transpiring leaf, I can simply set both conductances to zero. But, what about a rapidly transpiring leaf? It isn’t clear how one would model this scenario. Set both conductances to infinity? Look up reasonable values in the literature?</p> <p>Another drawback is that the mathematical complexity of energy balance models makes them slow to calculate. Leaf temperature appears in multiple places in the model, so one must solve the system numerically. For lightweight modeling work this doesn’t matter too much. But, if I want to implement an energy balance model with remote sensing data, I quickly run into scaling issues.</p> <h1 id="approach-3-flux-tower-model">Approach 3: Flux tower model</h1> <p><a href="https://www.sciencedirect.com/science/article/pii/S0168192323002514">A recent paper in Agricultural and Forest Meteorology</a> presents an energy balance model derived from flux tower data. This model doesn’t have to be solved numerically (mostly), provides clear endmembers to represent stressed and unstressed leaves, and so far has excellent correspondence with measured leaf temperatures.</p> <p>Here is the model’s parameterization of leaf temperature.</p> \[T_L = T_a + \frac{Q_a r_H}{k \rho c_p}(1-f_E)\] <p>\(T_L\) is leaf temperature, \(T_a\) is air temperature, \(Q_a\) is net radiation, \(r_H\) is resistance to sensible heat transfer, \(k\) is the sidedness of the leaf, \(\rho\) is air density, \(c_p\) is heat capacity, and \(f_E\) is the “evaporative fraction”, or the proportion of \(Q_a\) that is dissipated by transpiration.</p> <p>The first thing to note is that this is very easy to calculate from flux tower data. \(Q_a\) corresponds to <code class="language-plaintext highlighter-rouge">NETRAD</code> in Ameriflux data products, and the resistance, density, and heat capacity parameters are easily approximated from meteorological data. We don’t have to consider leaf-level characteristics because these are all buried in the flux measurements that go into calculating <code class="language-plaintext highlighter-rouge">NETRAD</code>. I was able to reimplement this model in R and reproduce figures in the paper in about a day.</p> <p>The more important note is that \(f_E\) gives us a clear way to model stressed and unstressed plants with very few assumptions about leaf characteristics. When \(f_E = 0\), leaves are not transpiring at all. When \(f_E = 1\), leaves are transpiring about as fast as energy balance allows. One caveat is that if we manipulate \(f_E\), we have to calculate \(Q_a\) manually and end up solving the model numerically.</p> <p>The authors tested their model by comparing the modeled leaf temperature with measured canopy temperature from the flux tower (<code class="language-plaintext highlighter-rouge">T_CANOPY</code> in Ameriflux). The authors report good correspondence in their study sites in Arizona, which appear to only have one radiometer measuring canopy temperature on each tower.</p> <p>I was curious how this model would perform somewhere with a more complex canopy. So, I applied this model to flux data from Wind River Experimental Forest (US-xWR). This flux tower is great because it has six radiometers measuring canopy temperature along a vertical profile. If we recreate Figure 2 from the paper on data from the top and bottom of Wind River’s canopy, we also get pretty good correspondence.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/wref_kibler_eb_test-480.webp 480w,/assets/img/wref_kibler_eb_test-800.webp 800w,/assets/img/wref_kibler_eb_test-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/wref_kibler_eb_test.png" class="img-fluid z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>It seems like this approach overestimates leaf temperature in the upper canopy, but underestimates in the lower canopy. Overall, not bad at all. Since the <code class="language-plaintext highlighter-rouge">NETRAD</code> measurements come from the top of the canopy, it makes sense that we would have a slightly better model there. Also, this is a very back-of-the-envelope plot. For example, I’m not filtering to observations where the latent heat flux is transpiration-only.</p> <p>In summary, I think this new model for flux tower data is super cool. It works out of the box with flux tower data, is easy to calculate, lends itself well to modeling stressed plants, and seems to perform well in different environments. Bravo to the original authors!</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Different ways of modeling the temperature of leaves]]></summary></entry><entry><title type="html">Terrain metrics, by hand in R</title><link href="https://s-kganz.github.io/blog/2022/terrain-metrics/" rel="alternate" type="text/html" title="Terrain metrics, by hand in R"/><published>2022-12-13T12:00:00+00:00</published><updated>2022-12-13T12:00:00+00:00</updated><id>https://s-kganz.github.io/blog/2022/terrain-metrics</id><content type="html" xml:base="https://s-kganz.github.io/blog/2022/terrain-metrics/"><![CDATA[<p>Let’s talk about terrain metrics. For all the time I have spent thinking about slope, relief, curvature, etc., I realized that I had never sat down and calculated these metrics from a DEM by hand. But, it is important to know why the terrain metrics tools we use in ArcGIs/QGIS/Earth Engine/whatever work. So, here is an R approach to calculating terrain metrics by hand.</p> <p>For much of this post, I’m following along with the description of the Evans-Young method given in <a href="https://www.sciencedirect.com/book/9780128046326/digital-terrain-analysis-in-soil-science-and-geology">Florinsky 2012</a>, but using the notation in the original: <a href="https://www.researchgate.net/publication/279414703">Young and Evans 1978</a> Most GIS applications and software packages use this technique.</p> <h1 id="the-evans-young-method">The Evans-Young method</h1> <p>Consider a DEM \(Z\) with regular grid spacing \(w\) with each cell containing an elevation value \(z\). Let us focus on a 3x3 window around a central cell. The eight cells adjacent to the central cell in this window is the eight-neighborhood of the central cell. We will refer to the elevation values in the eight-neighborhood as follows:</p> \[\begin{bmatrix} z_1 &amp; z_2 &amp; z_3 \\ z_4 &amp; z_5 &amp; z_6 \\ z_7 &amp; z_8 &amp; z_9 \\ \end{bmatrix}\] <p>The coordinates of each elevation value in the eight neighborhood are:</p> \[\begin{bmatrix} (-w, w) &amp; (0, w) &amp; (w, w) \\ (-w, 0) &amp; (0, 0) &amp; (w, 0) \\ (-w, -w) &amp; (0, -w) &amp; (w, -w) \\ \end{bmatrix}\] <p>The core of the Evans-Young method is to fit a second-degree polynomial to these elevation values, compute the partial derivatives of the polynomial, and then compute terrain metrics from the partial derivatives. The polynomial to be fit is:</p> \[\begin{align*} z = rx^2 + ty^2 + sxy + px + qy + u. \end{align*}\] <p>So, the partial derivatives correspond to the coefficients:</p> \[\begin{align*} p &amp;= \frac{\partial z}{\partial x} \newline\newline q &amp;= \frac{\partial z}{\partial y} \newline\newline 2r &amp;= \frac{\partial^2 z}{\partial x^2} \newline\newline s &amp;= \frac{\partial^2 z}{\partial x \partial y} \newline\newline 2t &amp;= \frac{\partial^2 z}{\partial y^2} \end{align*}\] <p>The last coefficient, \(u\), is not a partial derivative, but it is still a part of the fitting process. Now, we have to go about fitting the coefficients. To do this, we can make use of the fact that we can write values of \(z_i\) as a system of equations. Using the indexing above, we can write that:</p> \[\begin{align*} z_1 &amp;= w^2r + w^2t - w^2s - wp + wq + u \newline z_2 &amp;= 0 + w^2t + 0 + 0 + wq + u \newline z_3 &amp;= w^2r + w^2t + w^2s + wp + wq + u \newline \vdots \end{align*}\] <p>This is a system of equations! To solve the system, we need to rewrite it in matrix form. Let \(\vec{z}\) be a column vector of elevation values indexed as above and let the coefficient vector \(\vec{\alpha} = (r, t, s, p, q, u)^T\). We can now write a matrix equation describing our eight-neighborhood as:</p> \[\mathbf{F}\vec{\alpha} = \vec{z}\] <p>\(\mathbf{F}\) is the matrix of coefficients containing \(w\) that we got when writing out the first few equations for \(z_i\). The full matrix is:</p> \[F = \begin{bmatrix} w^2 &amp; w^2 &amp; -w^2 &amp; -w &amp; w &amp; 1 \\ 0 &amp; w^2 &amp; 0 &amp; 0 &amp; w &amp; 1 \\ w^2 &amp; w^2 &amp; w^2 &amp; w &amp; w &amp; 1 \\ w^2 &amp; 0 &amp; 0 &amp; -w &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ w^2 &amp; 0 &amp; 0 &amp; w &amp; 0 &amp; 1 \\ w^2 &amp; w^2 &amp; w^2 &amp; -w &amp; -w &amp; 1 \\ 0 &amp; w^2 &amp; 0 &amp; 0 &amp; -w &amp; 1 \\ w^2 &amp; w^2 &amp; w^2 &amp; w &amp; -w &amp; 1 \end{bmatrix}\] <p>Note that the \(i\)-th row of \(\mathbf{F}\) corresponds to the equation for \(z_i\). Now let’s return to our matrix equation. To solve for \(\vec{\alpha}\), we need to eliminate \(\mathbf{F}\) from the left-hand side. We cannot take the inverse of \(\mathbf{F}\) since it is not square. So, we will multiply both sides of the equation by \(\mathbf{F^T}\) to create the square matrix \(\mathbf{F^T F}\). Now we have:</p> \[\mathbf{F^T F}\vec{\alpha} = \mathbf{F^T}\vec{z}\] <p>Finally, multiply both sides by the inverse of the square matrix we just created:</p> \[(\mathbf{F^T F})^{-1}\mathbf{F^T F}\vec{\alpha} = (\mathbf{F^T F})^{-1}\mathbf{F^T}\vec{z}\] <p>Since the left-hand side contains a matrix multiplied by its inverse, we are left with a 6x6 identity matrix that cancels out, giving us our solution:</p> \[\vec{\alpha} = (\mathbf{F^T F})^{-1}\mathbf{F^T}\vec{z}\] <p>On the right-hand side, we have:</p> \[(\mathbf{F^T F})^{-1}\mathbf{F^T} = \begin{bmatrix} \frac{1}{6w^2} &amp; \frac{-1}{3w^2} &amp; \frac{1}{6w^2} &amp; \frac{1}{6w^2} &amp; \frac{-1}{3w^2} &amp; \frac{1}{6w^2} &amp; \frac{1}{6w^2} &amp; \frac{-1}{3w^2} &amp; \frac{1}{6w^2} \\ \frac{1}{6w^2} &amp; \frac{1}{6w^2} &amp; \frac{1}{6w^2} &amp; \frac{-1}{3w^2} &amp; \frac{-1}{3w^2} &amp; \frac{-1}{3w^2} &amp; \frac{1}{6w^2} &amp; \frac{1}{6w^2} &amp; \frac{1}{6w^2} \\ \frac{-1}{4w^2} &amp; 0 &amp; \frac{1}{4w^2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{4w^2} &amp; 0 &amp; \frac{-1}{4w^2} \\ \frac{-1}{6w} &amp; 0 &amp; \frac{1}{6w} &amp; \frac{-1}{6w} &amp; 0 &amp; \frac{1}{6w} &amp; \frac{-1}{6w} &amp; 0 &amp; \frac{1}{6w} \\ \frac{1}{6w} &amp; \frac{1}{6w} &amp; \frac{1}{6w} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{-1}{6w} &amp; \frac{-1}{6w} &amp; \frac{-1}{6w} \\ \frac{-1}{9} &amp; \frac{2}{9} &amp; \frac{-1}{9} &amp; \frac{2}{9} &amp; \frac{5}{9} &amp; \frac{2}{9} &amp; \frac{-1}{9} &amp; \frac{2}{9} &amp; \frac{-1}{9} \\ \end{bmatrix}\] <p>(Believe me, I had about as much fun writing that in latex as you had reading it.)</p> <p>Now we are in business. Take a closer look at the row corresponding to \(u\). The vertical displacement of the polynomial is not just an average of all the elevation values! Each partial derivative is derived from the dot product of a row of the above matrix with the elevation vector \(\vec{z}\). For example:</p> \[\frac{\partial^2 z}{\partial x^2} = 2r = \frac{z_1 + z_3 + z_4 + z_6 + z_7 + z_9 - 2(z_2 + z_5 + z_8)}{3w^2}\] <p>Before going any further, think about this equation in the context of the eight-neighborhood. The coefficients in front of the \(z_i\)’s match the below matrix.</p> \[\begin{bmatrix} 1 &amp; -2 &amp; 1 \\ 1 &amp; -2 &amp; 1 \\ 1 &amp; -2 &amp; 1 \\ \end{bmatrix}\] <p>So, you can think of the partial derivatives as <em>convolutions of the DEM</em>. We can then rewrite the partial derivative \(R\) (capitalized because it applies to the entire image) as:</p> \[R = Z \ast \begin{bmatrix} 1 &amp; -2 &amp; 1 \\ 1 &amp; -2 &amp; 1 \\ 1 &amp; -2 &amp; 1 \\ \end{bmatrix} / 3w^2\] <p>All the other partials follow suit:</p> \[\begin{align*} P &amp;= Z \ast \begin{bmatrix} -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\ \end{bmatrix} / 6w \newline \newline Q &amp;= Z \ast \begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 0 \\ -1 &amp; -1 &amp; -1 \\ \end{bmatrix} / 6w \newline \newline S &amp;= Z \ast \begin{bmatrix} -1 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; -1 \\ \end{bmatrix} / 4w^2 \newline \newline 2T &amp;= Z \ast \begin{bmatrix} 1 &amp; 1 &amp; 1 \\ -2 &amp; -2 &amp; -2 \\ 1 &amp; 1 &amp; 1 \\ \end{bmatrix} / 3w^2 \newline \end{align*}\] <p>As an aside, the fact that these partials come from convolutions makes them simple to calculate in Earth Engine. In fact, this is exactly how the <a href="https://github.com/zecojls/tagee">Terrain Analysis in Google Earth Engine</a> package computes terrain metrics.</p> <p>With our partials in hand, we can now calculate first and second-order terrain metrics. Slope is simply the gradient of the original DEM.</p> \[G = \sqrt{p^2 + q^2}\] <p>Note the similarity between \(G\) and the gradient of the polynomial, \(\nabla z = \sqrt{(\frac{\partial z}{\partial x})^2 + (\frac{\partial z}{\partial y})^2}\). These are the same property!</p> <p>Horizontal and vertical curvature (aka <a href="https://www.esri.com/arcgis-blog/products/product/imagery/understanding-curvature-rasters/">planform and profile curvature</a>) describe how slope changes in a landscape. They are used to describe the valley-ness or ridge-ness of a landform.</p> \[\begin{align*} k_h &amp;= -\frac{2q^2r - 4pqr + 2p^2 t}{(p^2 + q^2)\sqrt{1+p^2+q^2}} \newline \newline k_v &amp;= -\frac{2p^2r + 4pqs + 2q^2t}{(p^2+q^2)(1+p^2+q^2)^{1.5}} \end{align*}\] <h1 id="an-r-implementation">An R implementation</h1> <p>Let’s play with some terrain metrics in R. We will start with an 8-neighborhood, visualize its Evans-Young polynomial, then calculate terrain metrics for the center cell. First, we will simply translate our convolutions described above into R. For those playing along at home, all the code for this post is in <a href="https://github.com/s-kganz/terrain">this GitHub repository</a>.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">get_evans_young_fit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">2</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">8</span><span class="p">]))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="m">3</span><span class="o">*</span><span class="n">w</span><span class="o">^</span><span class="m">2</span><span class="p">)</span><span class="w">
  </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">2</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">6</span><span class="p">]))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="m">3</span><span class="o">*</span><span class="n">w</span><span class="o">^</span><span class="m">2</span><span class="p">)</span><span class="w">
  </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="m">9</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="m">4</span><span class="o">*</span><span class="n">w</span><span class="o">^</span><span class="m">2</span><span class="p">)</span><span class="w">
  </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="m">7</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="m">6</span><span class="o">*</span><span class="n">w</span><span class="p">)</span><span class="w">
  </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="m">9</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="m">6</span><span class="o">*</span><span class="n">w</span><span class="p">)</span><span class="w">
  </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1</span><span class="o">/</span><span class="m">9</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="m">2</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">8</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="m">9</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">5</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="m">5</span><span class="p">])</span><span class="w">
  
  </span><span class="nf">list</span><span class="p">(</span><span class="w">
    </span><span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span><span class="p">}</span></code></pre></figure> <p>Now, we use the <code class="language-plaintext highlighter-rouge">plotly</code> library to render the resulting polynomial.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">library</span><span class="p">(</span><span class="n">plotly</span><span class="p">)</span><span class="w">
</span><span class="n">render_evans_young_fit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">partials</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_evans_young_fit</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w">
  </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">r</span><span class="w">
  </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">t</span><span class="w">
  </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">s</span><span class="w">
  </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">p</span><span class="w">
  </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">q</span><span class="w">
  </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">u</span><span class="w">
  
  </span><span class="c1"># The valid range of the polynomial is *always* [-1, 1] for both x</span><span class="w">
  </span><span class="c1"># and y axes.</span><span class="w">
  </span><span class="n">x_surf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">seq</span><span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">length.out</span><span class="o">=</span><span class="m">100</span><span class="p">)</span><span class="w">
  </span><span class="n">y_surf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">seq</span><span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">length.out</span><span class="o">=</span><span class="m">100</span><span class="p">)</span><span class="w">
  </span><span class="n">z_surf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">matrix</span><span class="p">(</span><span class="n">nrow</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">x_surf</span><span class="p">),</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">y_surf</span><span class="p">))</span><span class="w">
  
  </span><span class="c1"># This can be made much more efficient</span><span class="w">
  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">x_surf</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">y_surf</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="c1"># Note flip of j and i here since y is our "row" on the surface.</span><span class="w">
      </span><span class="n">z_surf</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">r</span><span class="o">*</span><span class="n">x_surf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="m">2</span><span class="o">/</span><span class="m">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">y_surf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">^</span><span class="m">2</span><span class="o">/</span><span class="m">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">x_surf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y_surf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w">
        </span><span class="n">p</span><span class="o">*</span><span class="n">x_surf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="o">*</span><span class="n">y_surf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="n">x_pts</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="m">3</span><span class="p">)</span><span class="w">
  </span><span class="n">y_pts</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">))</span><span class="w">
  
  </span><span class="n">plot_ly</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">add_surface</span><span class="p">(</span><span class="w">
      </span><span class="n">x</span><span class="o">=</span><span class="n">x_surf</span><span class="p">,</span><span class="w">
      </span><span class="n">y</span><span class="o">=</span><span class="n">y_surf</span><span class="p">,</span><span class="w">
      </span><span class="n">z</span><span class="o">=</span><span class="n">z_surf</span><span class="p">,</span><span class="w">
      </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.5</span><span class="w">
    </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">add_markers</span><span class="p">(</span><span class="w">
      </span><span class="n">x</span><span class="o">=</span><span class="n">x_pts</span><span class="p">,</span><span class="w">
      </span><span class="n">y</span><span class="o">=</span><span class="n">y_pts</span><span class="p">,</span><span class="w">
      </span><span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="w">
    </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">z</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="w">
    </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w">
    </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w">
    </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="p">)</span><span class="w">

</span><span class="n">render_evans_young_fit</span><span class="p">(</span><span class="n">z</span><span class="p">)</span></code></pre></figure> <iframe width="100%" height="400" frameborder="0" scrolling="no" src="//plotly.com/~ganzk/52.embed"></iframe> <p>We can also calculate terrain metrics for this surface.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">get_terrain_metrics</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">partials</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_evans_young_fit</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w">
  </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">r</span><span class="w">
  </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">t</span><span class="w">
  </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">s</span><span class="w">
  </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">p</span><span class="w">
  </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">partials</span><span class="o">$</span><span class="n">q</span><span class="w">
  
  </span><span class="n">slope</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">atan</span><span class="p">(</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">p</span><span class="o">^</span><span class="m">2</span><span class="o">+</span><span class="n">q</span><span class="o">^</span><span class="m">2</span><span class="p">))</span><span class="w"> </span><span class="c1"># in rads</span><span class="w">
  
  </span><span class="c1"># If p and q are both zero then the curvature result is 0/0, </span><span class="w">
  </span><span class="c1"># force to 0 since the surface is flat in this case.</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">h_curv</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0</span><span class="w">
    </span><span class="n">v_curv</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">h_curv</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">-1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="o">^</span><span class="m">2</span><span class="o">*</span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">2</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">^</span><span class="m">2</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w">
      </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">^</span><span class="m">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="o">^</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">sqrt</span><span class="p">(</span><span class="m">1</span><span class="o">+</span><span class="n">p</span><span class="o">^</span><span class="m">2</span><span class="o">+</span><span class="n">q</span><span class="o">^</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
    </span><span class="n">v_curv</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">-1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">^</span><span class="m">2</span><span class="o">*</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">2</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="o">^</span><span class="m">2</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w">
      </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">^</span><span class="m">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="o">^</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="m">1</span><span class="o">+</span><span class="n">p</span><span class="o">^</span><span class="m">2</span><span class="o">+</span><span class="n">q</span><span class="o">^</span><span class="m">2</span><span class="p">)</span><span class="o">^</span><span class="m">1.5</span><span class="w"> </span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="n">relief</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="nf">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w">
  </span><span class="n">grad</span><span class="w">   </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">relief</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">w</span><span class="w">
  
  
  </span><span class="nf">list</span><span class="p">(</span><span class="n">slope</span><span class="o">=</span><span class="n">slope</span><span class="p">,</span><span class="w"> </span><span class="n">h_curv</span><span class="o">=</span><span class="n">h_curv</span><span class="p">,</span><span class="w"> </span><span class="n">v_curv</span><span class="o">=</span><span class="n">v_curv</span><span class="p">,</span><span class="w">
       </span><span class="n">relief</span><span class="o">=</span><span class="n">relief</span><span class="p">,</span><span class="w"> </span><span class="n">grad</span><span class="o">=</span><span class="n">grad</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_terrain_metrics</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span><span class="w">
</span><span class="o">$</span><span class="n">slope</span><span class="w">
</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">0.8410687</span><span class="w">

</span><span class="o">$</span><span class="n">h_curv</span><span class="w">
</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">-0.2222222</span><span class="w">

</span><span class="o">$</span><span class="n">v_curv</span><span class="w">
</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">0.1975309</span><span class="w">

</span><span class="o">$</span><span class="n">relief</span><span class="w">
</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">2</span><span class="w">

</span><span class="o">$</span><span class="n">grad</span><span class="w">
</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">2</span></code></pre></figure> <p>Note that this approach to calculating terrain metrics may differ from that in your favorite GIS software. Another popular technique is given in <a href="https://ieeexplore.ieee.org/document/1456186">Horn (1981)</a>, and is currently in use in the R <code class="language-plaintext highlighter-rouge">raster</code> package.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Slope and curvature by the Evans-Young method]]></summary></entry><entry><title type="html">Perceptually Uniform Colormaps in Satellite Imagery</title><link href="https://s-kganz.github.io/blog/2021/puck/" rel="alternate" type="text/html" title="Perceptually Uniform Colormaps in Satellite Imagery"/><published>2021-01-28T12:00:00+00:00</published><updated>2021-01-28T12:00:00+00:00</updated><id>https://s-kganz.github.io/blog/2021/puck</id><content type="html" xml:base="https://s-kganz.github.io/blog/2021/puck/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[A writeup from the SentinelHub custom script contest]]></summary></entry></feed>